
AVRASM ver. 2.2.6  C:\Users\arnob\Documents\EPFL\BA4\Microcontroleurs\PROJET\src\MicrocontroleursBA4\ProjetBA4\ProjetBA4\keypadv2.asm Thu May 09 20:25:55 2024

[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.1.130\avrasm\inc\m128def.inc'
C:\Users\arnob\Documents\EPFL\BA4\Microcontroleurs\PROJET\src\MicrocontroleursBA4\ProjetBA4\ProjetBA4\keypadv2.asm(18): Including file 'C:\Users\arnob\Documents\EPFL\BA4\Microcontroleurs\PROJET\src\MicrocontroleursBA4\ProjetBA4\ProjetBA4\macros.asm'
C:\Users\arnob\Documents\EPFL\BA4\Microcontroleurs\PROJET\src\MicrocontroleursBA4\ProjetBA4\ProjetBA4\keypadv2.asm(19): Including file 'C:\Users\arnob\Documents\EPFL\BA4\Microcontroleurs\PROJET\src\MicrocontroleursBA4\ProjetBA4\ProjetBA4\definitions.asm'
C:\Users\arnob\Documents\EPFL\BA4\Microcontroleurs\PROJET\src\MicrocontroleursBA4\ProjetBA4\ProjetBA4\keypadv2.asm(28): warning: Register r2 already defined by the .DEF directive
C:\Users\arnob\Documents\EPFL\BA4\Microcontroleurs\PROJET\src\MicrocontroleursBA4\ProjetBA4\ProjetBA4\keypadv2.asm(29): warning: Register r1 already defined by the .DEF directive
C:\Users\arnob\Documents\EPFL\BA4\Microcontroleurs\PROJET\src\MicrocontroleursBA4\ProjetBA4\ProjetBA4\keypadv2.asm(30): warning: Register r14 already defined by the .DEF directive
C:\Users\arnob\Documents\EPFL\BA4\Microcontroleurs\PROJET\src\MicrocontroleursBA4\ProjetBA4\ProjetBA4\keypadv2.asm(31): warning: Register r15 already defined by the .DEF directive
C:\Users\arnob\Documents\EPFL\BA4\Microcontroleurs\PROJET\src\MicrocontroleursBA4\ProjetBA4\ProjetBA4\keypadv2.asm(137): Including file 'C:\Users\arnob\Documents\EPFL\BA4\Microcontroleurs\PROJET\src\MicrocontroleursBA4\ProjetBA4\ProjetBA4\lcd.asm'
C:\Users\arnob\Documents\EPFL\BA4\Microcontroleurs\PROJET\src\MicrocontroleursBA4\ProjetBA4\ProjetBA4\keypadv2.asm(138): Including file 'C:\Users\arnob\Documents\EPFL\BA4\Microcontroleurs\PROJET\src\MicrocontroleursBA4\ProjetBA4\ProjetBA4\printf.asm'
[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.1.130\avrasm\inc\m128def.inc'
C:\Users\arnob\Documents\EPFL\BA4\Microcontroleurs\PROJET\src\MicrocontroleursBA4\ProjetBA4\ProjetBA4\keypadv2.asm(18): Including file 'C:\Users\arnob\Documents\EPFL\BA4\Microcontroleurs\PROJET\src\MicrocontroleursBA4\ProjetBA4\ProjetBA4\macros.asm'
C:\Users\arnob\Documents\EPFL\BA4\Microcontroleurs\PROJET\src\MicrocontroleursBA4\ProjetBA4\ProjetBA4\keypadv2.asm(19): Including file 'C:\Users\arnob\Documents\EPFL\BA4\Microcontroleurs\PROJET\src\MicrocontroleursBA4\ProjetBA4\ProjetBA4\definitions.asm'
C:\Users\arnob\Documents\EPFL\BA4\Microcontroleurs\PROJET\src\MicrocontroleursBA4\ProjetBA4\ProjetBA4\keypadv2.asm(137): Including file 'C:\Users\arnob\Documents\EPFL\BA4\Microcontroleurs\PROJET\src\MicrocontroleursBA4\ProjetBA4\ProjetBA4\lcd.asm'
C:\Users\arnob\Documents\EPFL\BA4\Microcontroleurs\PROJET\src\MicrocontroleursBA4\ProjetBA4\ProjetBA4\keypadv2.asm(138): Including file 'C:\Users\arnob\Documents\EPFL\BA4\Microcontroleurs\PROJET\src\MicrocontroleursBA4\ProjetBA4\ProjetBA4\printf.asm'
                                 
                                 ; file	kpd4x4_S.asm   target ATmega128L-4MHz-STK300		
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega128.xml ***********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m128def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega128
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega128
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M128DEF_INC_
                                 #define _M128DEF_INC_
                                 
                                 
                                 #pragma partinc 0
                                 
                                 ; ***** SPECIFY DEVICE ***************************************************
                                 .device ATmega128
                                 #pragma AVRPART ADMIN PART_NAME ATmega128
                                 .equ	SIGNATURE_000	= 0x1e
                                 .equ	SIGNATURE_001	= 0x97
                                 .equ	SIGNATURE_002	= 0x02
                                 
                                 #pragma AVRPART CORE CORE_VERSION V2E
                                 
                                 
                                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                                 ; NOTE:
                                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                                 ; and cannot be used with IN/OUT instructions
                                 .equ	UCSR1C	= 0x9d	; MEMORY MAPPED
                                 .equ	UDR1	= 0x9c	; MEMORY MAPPED
                                 .equ	UCSR1A	= 0x9b	; MEMORY MAPPED
                                 .equ	UCSR1B	= 0x9a	; MEMORY MAPPED
                                 .equ	UBRR1H	= 0x98	; MEMORY MAPPED
                                 .equ	UBRR1L	= 0x99	; MEMORY MAPPED
                                 .equ	UCSR0C	= 0x95	; MEMORY MAPPED
                                 .equ	UBRR0H	= 0x90	; MEMORY MAPPED
                                 .equ	TCCR3C	= 0x8c	; MEMORY MAPPED
                                 .equ	TCCR3A	= 0x8b	; MEMORY MAPPED
                                 .equ	TCCR3B	= 0x8a	; MEMORY MAPPED
                                 .equ	TCNT3L	= 0x88	; MEMORY MAPPED
                                 .equ	TCNT3H	= 0x89	; MEMORY MAPPED
                                 .equ	OCR3AL	= 0x86	; MEMORY MAPPED
                                 .equ	OCR3AH	= 0x87	; MEMORY MAPPED
                                 .equ	OCR3BL	= 0x84	; MEMORY MAPPED
                                 .equ	OCR3BH	= 0x85	; MEMORY MAPPED
                                 .equ	OCR3CL	= 0x82	; MEMORY MAPPED
                                 .equ	OCR3CH	= 0x83	; MEMORY MAPPED
                                 .equ	ICR3L	= 0x80	; MEMORY MAPPED
                                 .equ	ICR3H	= 0x81	; MEMORY MAPPED
                                 .equ	ETIMSK	= 0x7d	; MEMORY MAPPED
                                 .equ	ETIFR	= 0x7c	; MEMORY MAPPED
                                 .equ	TCCR1C	= 0x7a	; MEMORY MAPPED
                                 .equ	OCR1CL	= 0x78	; MEMORY MAPPED
                                 .equ	OCR1CH	= 0x79	; MEMORY MAPPED
                                 .equ	TWCR	= 0x74	; MEMORY MAPPED
                                 .equ	TWDR	= 0x73	; MEMORY MAPPED
                                 .equ	TWAR	= 0x72	; MEMORY MAPPED
                                 .equ	TWSR	= 0x71	; MEMORY MAPPED
                                 .equ	TWBR	= 0x70	; MEMORY MAPPED
                                 .equ	OSCCAL	= 0x6f	; MEMORY MAPPED
                                 .equ	XMCRA	= 0x6d	; MEMORY MAPPED
                                 .equ	XMCRB	= 0x6c	; MEMORY MAPPED
                                 .equ	EICRA	= 0x6a	; MEMORY MAPPED
                                 .equ	SPMCSR	= 0x68	; MEMORY MAPPED
                                 .equ	PORTG	= 0x65	; MEMORY MAPPED
                                 .equ	DDRG	= 0x64	; MEMORY MAPPED
                                 .equ	PING	= 0x63	; MEMORY MAPPED
                                 .equ	PORTF	= 0x62	; MEMORY MAPPED
                                 .equ	DDRF	= 0x61	; MEMORY MAPPED
                                 .equ	SREG	= 0x3f
                                 .equ	SPL	= 0x3d
                                 .equ	SPH	= 0x3e
                                 .equ	XDIV	= 0x3c
                                 .equ	RAMPZ	= 0x3b
                                 .equ	EICRB	= 0x3a
                                 .equ	EIMSK	= 0x39
                                 .equ	EIFR	= 0x38
                                 .equ	TIMSK	= 0x37
                                 .equ	TIFR	= 0x36
                                 .equ	MCUCR	= 0x35
                                 .equ	MCUCSR	= 0x34
                                 .equ	TCCR0	= 0x33
                                 .equ	TCNT0	= 0x32
                                 .equ	OCR0	= 0x31
                                 .equ	ASSR	= 0x30
                                 .equ	TCCR1A	= 0x2f
                                 .equ	TCCR1B	= 0x2e
                                 .equ	TCNT1L	= 0x2c
                                 .equ	TCNT1H	= 0x2d
                                 .equ	OCR1AL	= 0x2a
                                 .equ	OCR1AH	= 0x2b
                                 .equ	OCR1BL	= 0x28
                                 .equ	OCR1BH	= 0x29
                                 .equ	ICR1L	= 0x26
                                 .equ	ICR1H	= 0x27
                                 .equ	TCCR2	= 0x25
                                 .equ	TCNT2	= 0x24
                                 .equ	OCR2	= 0x23
                                 .equ	OCDR	= 0x22
                                 .equ	WDTCR	= 0x21
                                 .equ	SFIOR	= 0x20
                                 .equ	EEARL	= 0x1e
                                 .equ	EEARH	= 0x1f
                                 .equ	EEDR	= 0x1d
                                 .equ	EECR	= 0x1c
                                 .equ	PORTA	= 0x1b
                                 .equ	DDRA	= 0x1a
                                 .equ	PINA	= 0x19
                                 .equ	PORTB	= 0x18
                                 .equ	DDRB	= 0x17
                                 .equ	PINB	= 0x16
                                 .equ	PORTC	= 0x15
                                 .equ	DDRC	= 0x14
                                 .equ	PINC	= 0x13
                                 .equ	PORTD	= 0x12
                                 .equ	DDRD	= 0x11
                                 .equ	PIND	= 0x10
                                 .equ	SPDR	= 0x0f
                                 .equ	SPSR	= 0x0e
                                 .equ	SPCR	= 0x0d
                                 .equ	UDR0	= 0x0c
                                 .equ	UCSR0A	= 0x0b
                                 .equ	UCSR0B	= 0x0a
                                 .equ	UBRR0L	= 0x09
                                 .equ	ACSR	= 0x08
                                 .equ	ADMUX	= 0x07
                                 .equ	ADCSRA	= 0x06
                                 .equ	ADCH	= 0x05
                                 .equ	ADCL	= 0x04
                                 .equ	PORTE	= 0x03
                                 .equ	DDRE	= 0x02
                                 .equ	PINE	= 0x01
                                 .equ	PINF	= 0x00
                                 
                                 
                                 ; ***** BIT DEFINITIONS **************************************************
                                 
                                 ; ***** ANALOG_COMPARATOR ************
                                 ; SFIOR - Special Function IO Register
                                 .equ	ACME	= 3	; Analog Comparator Multiplexer Enable
                                 
                                 ; ACSR - Analog Comparator Control And Status Register
                                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                                 .equ	ACO	= 5	; Analog Compare Output
                                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                                 .equ	ACD	= 7	; Analog Comparator Disable
                                 
                                 
                                 ; ***** SPI **************************
                                 ; SPDR - SPI Data Register
                                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                                 
                                 ; SPSR - SPI Status Register
                                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                                 .equ	WCOL	= 6	; Write Collision Flag
                                 .equ	SPIF	= 7	; SPI Interrupt Flag
                                 
                                 ; SPCR - SPI Control Register
                                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                                 .equ	CPHA	= 2	; Clock Phase
                                 .equ	CPOL	= 3	; Clock polarity
                                 .equ	MSTR	= 4	; Master/Slave Select
                                 .equ	DORD	= 5	; Data Order
                                 .equ	SPE	= 6	; SPI Enable
                                 .equ	SPIE	= 7	; SPI Interrupt Enable
                                 
                                 
                                 ; ***** TWI **************************
                                 ; TWBR - TWI Bit Rate register
                                 .equ	I2BR	= TWBR	; For compatibility
                                 .equ	TWBR0	= 0	; 
                                 .equ	TWBR1	= 1	; 
                                 .equ	TWBR2	= 2	; 
                                 .equ	TWBR3	= 3	; 
                                 .equ	TWBR4	= 4	; 
                                 .equ	TWBR5	= 5	; 
                                 .equ	TWBR6	= 6	; 
                                 .equ	TWBR7	= 7	; 
                                 
                                 ; TWCR - TWI Control Register
                                 .equ	I2CR	= TWCR	; For compatibility
                                 .equ	TWIE	= 0	; TWI Interrupt Enable
                                 .equ	I2IE	= TWIE	; For compatibility
                                 .equ	TWEN	= 2	; TWI Enable Bit
                                 .equ	I2EN	= TWEN	; For compatibility
                                 .equ	ENI2C	= TWEN	; For compatibility
                                 .equ	TWWC	= 3	; TWI Write Collition Flag
                                 .equ	I2WC	= TWWC	; For compatibility
                                 .equ	TWSTO	= 4	; TWI Stop Condition Bit
                                 .equ	I2STO	= TWSTO	; For compatibility
                                 .equ	TWSTA	= 5	; TWI Start Condition Bit
                                 .equ	I2STA	= TWSTA	; For compatibility
                                 .equ	TWEA	= 6	; TWI Enable Acknowledge Bit
                                 .equ	I2EA	= TWEA	; For compatibility
                                 .equ	TWINT	= 7	; TWI Interrupt Flag
                                 .equ	I2INT	= TWINT	; For compatibility
                                 
                                 ; TWSR - TWI Status Register
                                 .equ	I2SR	= TWSR	; For compatibility
                                 .equ	TWPS0	= 0	; TWI Prescaler
                                 .equ	TWS0	= TWPS0	; For compatibility
                                 .equ	I2GCE	= TWPS0	; For compatibility
                                 .equ	TWPS1	= 1	; TWI Prescaler
                                 .equ	TWS1	= TWPS1	; For compatibility
                                 .equ	TWS3	= 3	; TWI Status
                                 .equ	I2S3	= TWS3	; For compatibility
                                 .equ	TWS4	= 4	; TWI Status
                                 .equ	I2S4	= TWS4	; For compatibility
                                 .equ	TWS5	= 5	; TWI Status
                                 .equ	I2S5	= TWS5	; For compatibility
                                 .equ	TWS6	= 6	; TWI Status
                                 .equ	I2S6	= TWS6	; For compatibility
                                 .equ	TWS7	= 7	; TWI Status
                                 .equ	I2S7	= TWS7	; For compatibility
                                 
                                 ; TWDR - TWI Data register
                                 .equ	I2DR	= TWDR	; For compatibility
                                 .equ	TWD0	= 0	; TWI Data Register Bit 0
                                 .equ	TWD1	= 1	; TWI Data Register Bit 1
                                 .equ	TWD2	= 2	; TWI Data Register Bit 2
                                 .equ	TWD3	= 3	; TWI Data Register Bit 3
                                 .equ	TWD4	= 4	; TWI Data Register Bit 4
                                 .equ	TWD5	= 5	; TWI Data Register Bit 5
                                 .equ	TWD6	= 6	; TWI Data Register Bit 6
                                 .equ	TWD7	= 7	; TWI Data Register Bit 7
                                 
                                 ; TWAR - TWI (Slave) Address register
                                 .equ	I2AR	= TWAR	; For compatibility
                                 .equ	TWGCE	= 0	; TWI General Call Recognition Enable Bit
                                 .equ	TWA0	= 1	; TWI (Slave) Address register Bit 0
                                 .equ	TWA1	= 2	; TWI (Slave) Address register Bit 1
                                 .equ	TWA2	= 3	; TWI (Slave) Address register Bit 2
                                 .equ	TWA3	= 4	; TWI (Slave) Address register Bit 3
                                 .equ	TWA4	= 5	; TWI (Slave) Address register Bit 4
                                 .equ	TWA5	= 6	; TWI (Slave) Address register Bit 5
                                 .equ	TWA6	= 7	; TWI (Slave) Address register Bit 6
                                 
                                 
                                 ; ***** USART0 ***********************
                                 ; UDR0 - USART I/O Data Register
                                 .equ	UDR00	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR01	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR02	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR03	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR04	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR05	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR06	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR07	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR0A - USART Control and Status Register A
                                 .equ	MPCM0	= 0	; Multi-processor Communication Mode
                                 .equ	U2X0	= 1	; Double the USART transmission speed
                                 .equ	UPE0	= 2	; Parity Error
                                 .equ	DOR0	= 3	; Data overRun
                                 .equ	FE0	= 4	; Framing Error
                                 .equ	UDRE0	= 5	; USART Data Register Empty
                                 .equ	TXC0	= 6	; USART Transmitt Complete
                                 .equ	RXC0	= 7	; USART Receive Complete
                                 
                                 ; UCSR0B - USART Control and Status Register B
                                 .equ	TXB80	= 0	; Transmit Data Bit 8
                                 .equ	RXB80	= 1	; Receive Data Bit 8
                                 .equ	UCSZ02	= 2	; Character Size
                                 .equ	UCSZ2	= UCSZ02	; For compatibility
                                 .equ	TXEN0	= 3	; Transmitter Enable
                                 .equ	RXEN0	= 4	; Receiver Enable
                                 .equ	UDRIE0	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE0	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE0	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR0C - USART Control and Status Register C
                                 .equ	UCPOL0	= 0	; Clock Polarity
                                 .equ	UCSZ00	= 1	; Character Size
                                 .equ	UCSZ01	= 2	; Character Size
                                 .equ	USBS0	= 3	; Stop Bit Select
                                 .equ	UPM00	= 4	; Parity Mode Bit 0
                                 .equ	UPM01	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL0	= 6	; USART Mode Select
                                 
                                 ; UBRR0H - USART Baud Rate Register Hight Byte
                                 .equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 .equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 .equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 .equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR0L - USART Baud Rate Register Low Byte
                                 .equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                                 .equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                                 .equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                                 .equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                                 .equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                                 .equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                                 .equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                                 .equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** USART1 ***********************
                                 ; UDR1 - USART I/O Data Register
                                 .equ	UDR10	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR11	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR12	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR13	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR14	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR15	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR16	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR17	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR1A - USART Control and Status Register A
                                 .equ	MPCM1	= 0	; Multi-processor Communication Mode
                                 .equ	U2X1	= 1	; Double the USART transmission speed
                                 .equ	UPE1	= 2	; Parity Error
                                 .equ	DOR1	= 3	; Data overRun
                                 .equ	FE1	= 4	; Framing Error
                                 .equ	UDRE1	= 5	; USART Data Register Empty
                                 .equ	TXC1	= 6	; USART Transmitt Complete
                                 .equ	RXC1	= 7	; USART Receive Complete
                                 
                                 ; UCSR1B - USART Control and Status Register B
                                 .equ	TXB81	= 0	; Transmit Data Bit 8
                                 .equ	RXB81	= 1	; Receive Data Bit 8
                                 .equ	UCSZ12	= 2	; Character Size
                                 .equ	TXEN1	= 3	; Transmitter Enable
                                 .equ	RXEN1	= 4	; Receiver Enable
                                 .equ	UDRIE1	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE1	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE1	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR1C - USART Control and Status Register C
                                 .equ	UCPOL1	= 0	; Clock Polarity
                                 .equ	UCSZ10	= 1	; Character Size
                                 .equ	UCSZ11	= 2	; Character Size
                                 .equ	USBS1	= 3	; Stop Bit Select
                                 .equ	UPM10	= 4	; Parity Mode Bit 0
                                 .equ	UPM11	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL1	= 6	; USART Mode Select
                                 
                                 ; UBRR1H - USART Baud Rate Register Hight Byte
                                 ;.equ	UBRR8	= 0	; USART Baud Rate Register bit 8
                                 ;.equ	UBRR9	= 1	; USART Baud Rate Register bit 9
                                 ;.equ	UBRR10	= 2	; USART Baud Rate Register bit 10
                                 ;.equ	UBRR11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR1L - USART Baud Rate Register Low Byte
                                 ;.equ	UBRR0	= 0	; USART Baud Rate Register bit 0
                                 ;.equ	UBRR1	= 1	; USART Baud Rate Register bit 1
                                 ;.equ	UBRR2	= 2	; USART Baud Rate Register bit 2
                                 ;.equ	UBRR3	= 3	; USART Baud Rate Register bit 3
                                 ;.equ	UBRR4	= 4	; USART Baud Rate Register bit 4
                                 ;.equ	UBRR5	= 5	; USART Baud Rate Register bit 5
                                 ;.equ	UBRR6	= 6	; USART Baud Rate Register bit 6
                                 ;.equ	UBRR7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** CPU **************************
                                 ; SREG - Status Register
                                 .equ	SREG_C	= 0	; Carry Flag
                                 .equ	SREG_Z	= 1	; Zero Flag
                                 .equ	SREG_N	= 2	; Negative Flag
                                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                                 .equ	SREG_S	= 4	; Sign Bit
                                 .equ	SREG_H	= 5	; Half Carry Flag
                                 .equ	SREG_T	= 6	; Bit Copy Storage
                                 .equ	SREG_I	= 7	; Global Interrupt Enable
                                 
                                 ; MCUCR - MCU Control Register
                                 .equ	IVCE	= 0	; Interrupt Vector Change Enable
                                 .equ	IVSEL	= 1	; Interrupt Vector Select
                                 .equ	SM2	= 2	; Sleep Mode Select
                                 .equ	SM0	= 3	; Sleep Mode Select
                                 .equ	SM1	= 4	; Sleep Mode Select
                                 .equ	SE	= 5	; Sleep Enable
                                 .equ	SRW10	= 6	; External SRAM Wait State Select
                                 .equ	SRE	= 7	; External SRAM Enable
                                 
                                 ; XMCRA - External Memory Control Register A
                                 .equ	SRW11	= 1	; Wait state select bit upper page
                                 .equ	SRW00	= 2	; Wait state select bit lower page
                                 .equ	SRW01	= 3	; Wait state select bit lower page
                                 .equ	SRL0	= 4	; Wait state page limit
                                 .equ	SRL1	= 5	; Wait state page limit
                                 .equ	SRL2	= 6	; Wait state page limit
                                 
                                 ; XMCRB - External Memory Control Register B
                                 .equ	XMM0	= 0	; External Memory High Mask
                                 .equ	XMM1	= 1	; External Memory High Mask
                                 .equ	XMM2	= 2	; External Memory High Mask
                                 .equ	XMBK	= 7	; External Memory Bus Keeper Enable
                                 
                                 ; OSCCAL - Oscillator Calibration Value
                                 .equ	CAL0	= 0	; Oscillator Calibration Value
                                 .equ	CAL1	= 1	; Oscillator Calibration Value
                                 .equ	CAL2	= 2	; Oscillator Calibration Value
                                 .equ	CAL3	= 3	; Oscillator Calibration Value
                                 .equ	CAL4	= 4	; Oscillator Calibration Value
                                 .equ	CAL5	= 5	; Oscillator Calibration Value
                                 .equ	CAL6	= 6	; Oscillator Calibration Value
                                 .equ	CAL7	= 7	; Oscillator Calibration Value
                                 
                                 ; XDIV - XTAL Divide Control Register
                                 .equ	XDIV0	= 0	; XTAl Divide Select Bit 0
                                 .equ	XDIV1	= 1	; XTAl Divide Select Bit 1
                                 .equ	XDIV2	= 2	; XTAl Divide Select Bit 2
                                 .equ	XDIV3	= 3	; XTAl Divide Select Bit 3
                                 .equ	XDIV4	= 4	; XTAl Divide Select Bit 4
                                 .equ	XDIV5	= 5	; XTAl Divide Select Bit 5
                                 .equ	XDIV6	= 6	; XTAl Divide Select Bit 6
                                 .equ	XDIVEN	= 7	; XTAL Divide Enable
                                 
                                 ; MCUCSR - MCU Control And Status Register
                                 .equ	PORF	= 0	; Power-on reset flag
                                 .equ	EXTRF	= 1	; External Reset Flag
                                 .equ	BORF	= 2	; Brown-out Reset Flag
                                 .equ	WDRF	= 3	; Watchdog Reset Flag
                                 .equ	JTRF	= 4	; JTAG Reset Flag
                                 .equ	JTD	= 7	; JTAG Interface Disable
                                 
                                 ; RAMPZ - RAM Page Z Select Register
                                 .equ	RAMPZ0	= 0	; RAM Page Z Select Register Bit 0
                                 
                                 
                                 ; ***** BOOT_LOAD ********************
                                 ; SPMCSR - Store Program Memory Control Register
                                 .equ	SPMCR	= SPMCSR	; For compatibility
                                 .equ	SPMEN	= 0	; Store Program Memory Enable
                                 .equ	PGERS	= 1	; Page Erase
                                 .equ	PGWRT	= 2	; Page Write
                                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                                 .equ	RWWSRE	= 4	; Read While Write section read enable
                                 .equ	ASRE	= RWWSRE	; For compatibility
                                 .equ	RWWSB	= 6	; Read While Write Section Busy
                                 .equ	ASB	= RWWSB	; For compatibility
                                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                                 
                                 
                                 ; ***** JTAG *************************
                                 ; OCDR - On-Chip Debug Related Register in I/O Memory
                                 .equ	OCDR0	= 0	; On-Chip Debug Register Bit 0
                                 .equ	OCDR1	= 1	; On-Chip Debug Register Bit 1
                                 .equ	OCDR2	= 2	; On-Chip Debug Register Bit 2
                                 .equ	OCDR3	= 3	; On-Chip Debug Register Bit 3
                                 .equ	OCDR4	= 4	; On-Chip Debug Register Bit 4
                                 .equ	OCDR5	= 5	; On-Chip Debug Register Bit 5
                                 .equ	OCDR6	= 6	; On-Chip Debug Register Bit 6
                                 .equ	OCDR7	= 7	; On-Chip Debug Register Bit 7
                                 .equ	IDRD	= OCDR7	; For compatibility
                                 
                                 ; MCUCSR - MCU Control And Status Register
                                 ;.equ	JTRF	= 4	; JTAG Reset Flag
                                 ;.equ	JTD	= 7	; JTAG Interface Disable
                                 
                                 
                                 ; ***** MISC *************************
                                 ; SFIOR - Special Function IO Register
                                 .equ	PSR321	= 0	; Prescaler Reset Timer/Counter3, Timer/Counter2, and Timer/Counter1
                                 .equ	PSR1	= PSR321	; For compatibility
                                 .equ	PSR2	= PSR321	; For compatibility
                                 .equ	PSR3	= PSR321	; For compatibility
                                 .equ	PSR0	= 1	; Prescaler Reset Timer/Counter0
                                 .equ	PUD	= 2	; Pull Up Disable
                                 ;.equ	ACME	= 3	; Analog Comparator Multiplexer Enable
                                 .equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** EXTERNAL_INTERRUPT ***********
                                 ; EICRA - External Interrupt Control Register A
                                 .equ	ISC00	= 0	; External Interrupt Sense Control Bit
                                 .equ	ISC01	= 1	; External Interrupt Sense Control Bit
                                 .equ	ISC10	= 2	; External Interrupt Sense Control Bit
                                 .equ	ISC11	= 3	; External Interrupt Sense Control Bit
                                 .equ	ISC20	= 4	; External Interrupt Sense Control Bit
                                 .equ	ISC21	= 5	; External Interrupt Sense Control Bit
                                 .equ	ISC30	= 6	; External Interrupt Sense Control Bit
                                 .equ	ISC31	= 7	; External Interrupt Sense Control Bit
                                 
                                 ; EICRB - External Interrupt Control Register B
                                 .equ	ISC40	= 0	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC41	= 1	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC50	= 2	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC51	= 3	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC60	= 4	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC61	= 5	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC70	= 6	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC71	= 7	; External Interrupt 7-4 Sense Control Bit
                                 
                                 ; EIMSK - External Interrupt Mask Register
                                 .equ	GICR	= EIMSK	; For compatibility
                                 .equ	GIMSK	= EIMSK	; For compatibility
                                 .equ	INT0	= 0	; External Interrupt Request 0 Enable
                                 .equ	INT1	= 1	; External Interrupt Request 1 Enable
                                 .equ	INT2	= 2	; External Interrupt Request 2 Enable
                                 .equ	INT3	= 3	; External Interrupt Request 3 Enable
                                 .equ	INT4	= 4	; External Interrupt Request 4 Enable
                                 .equ	INT5	= 5	; External Interrupt Request 5 Enable
                                 .equ	INT6	= 6	; External Interrupt Request 6 Enable
                                 .equ	INT7	= 7	; External Interrupt Request 7 Enable
                                 
                                 ; EIFR - External Interrupt Flag Register
                                 .equ	GIFR	= EIFR	; For compatibility
                                 .equ	INTF0	= 0	; External Interrupt Flag 0
                                 .equ	INTF1	= 1	; External Interrupt Flag 1
                                 .equ	INTF2	= 2	; External Interrupt Flag 2
                                 .equ	INTF3	= 3	; External Interrupt Flag 3
                                 .equ	INTF4	= 4	; External Interrupt Flag 4
                                 .equ	INTF5	= 5	; External Interrupt Flag 5
                                 .equ	INTF6	= 6	; External Interrupt Flag 6
                                 .equ	INTF7	= 7	; External Interrupt Flag 7
                                 
                                 
                                 ; ***** EEPROM ***********************
                                 ; EEDR - EEPROM Data Register
                                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                                 
                                 ; EECR - EEPROM Control Register
                                 .equ	EERE	= 0	; EEPROM Read Enable
                                 .equ	EEWE	= 1	; EEPROM Write Enable
                                 .equ	EEMWE	= 2	; EEPROM Master Write Enable
                                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                                 
                                 
                                 ; ***** PORTA ************************
                                 ; PORTA - Port A Data Register
                                 .equ	PORTA0	= 0	; Port A Data Register bit 0
                                 .equ	PA0	= 0	; For compatibility
                                 .equ	PORTA1	= 1	; Port A Data Register bit 1
                                 .equ	PA1	= 1	; For compatibility
                                 .equ	PORTA2	= 2	; Port A Data Register bit 2
                                 .equ	PA2	= 2	; For compatibility
                                 .equ	PORTA3	= 3	; Port A Data Register bit 3
                                 .equ	PA3	= 3	; For compatibility
                                 .equ	PORTA4	= 4	; Port A Data Register bit 4
                                 .equ	PA4	= 4	; For compatibility
                                 .equ	PORTA5	= 5	; Port A Data Register bit 5
                                 .equ	PA5	= 5	; For compatibility
                                 .equ	PORTA6	= 6	; Port A Data Register bit 6
                                 .equ	PA6	= 6	; For compatibility
                                 .equ	PORTA7	= 7	; Port A Data Register bit 7
                                 .equ	PA7	= 7	; For compatibility
                                 
                                 ; DDRA - Port A Data Direction Register
                                 .equ	DDA0	= 0	; Data Direction Register, Port A, bit 0
                                 .equ	DDA1	= 1	; Data Direction Register, Port A, bit 1
                                 .equ	DDA2	= 2	; Data Direction Register, Port A, bit 2
                                 .equ	DDA3	= 3	; Data Direction Register, Port A, bit 3
                                 .equ	DDA4	= 4	; Data Direction Register, Port A, bit 4
                                 .equ	DDA5	= 5	; Data Direction Register, Port A, bit 5
                                 .equ	DDA6	= 6	; Data Direction Register, Port A, bit 6
                                 .equ	DDA7	= 7	; Data Direction Register, Port A, bit 7
                                 
                                 ; PINA - Port A Input Pins
                                 .equ	PINA0	= 0	; Input Pins, Port A bit 0
                                 .equ	PINA1	= 1	; Input Pins, Port A bit 1
                                 .equ	PINA2	= 2	; Input Pins, Port A bit 2
                                 .equ	PINA3	= 3	; Input Pins, Port A bit 3
                                 .equ	PINA4	= 4	; Input Pins, Port A bit 4
                                 .equ	PINA5	= 5	; Input Pins, Port A bit 5
                                 .equ	PINA6	= 6	; Input Pins, Port A bit 6
                                 .equ	PINA7	= 7	; Input Pins, Port A bit 7
                                 
                                 
                                 ; ***** PORTB ************************
                                 ; PORTB - Port B Data Register
                                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                                 .equ	PB0	= 0	; For compatibility
                                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                                 .equ	PB1	= 1	; For compatibility
                                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                                 .equ	PB2	= 2	; For compatibility
                                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                                 .equ	PB3	= 3	; For compatibility
                                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                                 .equ	PB4	= 4	; For compatibility
                                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                                 .equ	PB5	= 5	; For compatibility
                                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                                 .equ	PB6	= 6	; For compatibility
                                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                                 .equ	PB7	= 7	; For compatibility
                                 
                                 ; DDRB - Port B Data Direction Register
                                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                                 
                                 ; PINB - Port B Input Pins
                                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                                 
                                 
                                 ; ***** PORTC ************************
                                 ; PORTC - Port C Data Register
                                 .equ	PORTC0	= 0	; Port C Data Register bit 0
                                 .equ	PC0	= 0	; For compatibility
                                 .equ	PORTC1	= 1	; Port C Data Register bit 1
                                 .equ	PC1	= 1	; For compatibility
                                 .equ	PORTC2	= 2	; Port C Data Register bit 2
                                 .equ	PC2	= 2	; For compatibility
                                 .equ	PORTC3	= 3	; Port C Data Register bit 3
                                 .equ	PC3	= 3	; For compatibility
                                 .equ	PORTC4	= 4	; Port C Data Register bit 4
                                 .equ	PC4	= 4	; For compatibility
                                 .equ	PORTC5	= 5	; Port C Data Register bit 5
                                 .equ	PC5	= 5	; For compatibility
                                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                                 .equ	PC6	= 6	; For compatibility
                                 .equ	PORTC7	= 7	; Port C Data Register bit 7
                                 .equ	PC7	= 7	; For compatibility
                                 
                                 ; DDRC - Port C Data Direction Register
                                 .equ	DDC0	= 0	; Port C Data Direction Register bit 0
                                 .equ	DDC1	= 1	; Port C Data Direction Register bit 1
                                 .equ	DDC2	= 2	; Port C Data Direction Register bit 2
                                 .equ	DDC3	= 3	; Port C Data Direction Register bit 3
                                 .equ	DDC4	= 4	; Port C Data Direction Register bit 4
                                 .equ	DDC5	= 5	; Port C Data Direction Register bit 5
                                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                                 .equ	DDC7	= 7	; Port C Data Direction Register bit 7
                                 
                                 ; PINC - Port C Input Pins
                                 .equ	PINC0	= 0	; Port C Input Pins bit 0
                                 .equ	PINC1	= 1	; Port C Input Pins bit 1
                                 .equ	PINC2	= 2	; Port C Input Pins bit 2
                                 .equ	PINC3	= 3	; Port C Input Pins bit 3
                                 .equ	PINC4	= 4	; Port C Input Pins bit 4
                                 .equ	PINC5	= 5	; Port C Input Pins bit 5
                                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                                 .equ	PINC7	= 7	; Port C Input Pins bit 7
                                 
                                 
                                 ; ***** PORTD ************************
                                 ; PORTD - Port D Data Register
                                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                                 .equ	PD0	= 0	; For compatibility
                                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                                 .equ	PD1	= 1	; For compatibility
                                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                                 .equ	PD2	= 2	; For compatibility
                                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                                 .equ	PD3	= 3	; For compatibility
                                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                                 .equ	PD4	= 4	; For compatibility
                                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                                 .equ	PD5	= 5	; For compatibility
                                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                                 .equ	PD6	= 6	; For compatibility
                                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                                 .equ	PD7	= 7	; For compatibility
                                 
                                 ; DDRD - Port D Data Direction Register
                                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                                 
                                 ; PIND - Port D Input Pins
                                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                                 
                                 
                                 ; ***** PORTE ************************
                                 ; PORTE - Data Register, Port E
                                 .equ	PORTE0	= 0	; 
                                 .equ	PE0	= 0	; For compatibility
                                 .equ	PORTE1	= 1	; 
                                 .equ	PE1	= 1	; For compatibility
                                 .equ	PORTE2	= 2	; 
                                 .equ	PE2	= 2	; For compatibility
                                 .equ	PORTE3	= 3	; 
                                 .equ	PE3	= 3	; For compatibility
                                 .equ	PORTE4	= 4	; 
                                 .equ	PE4	= 4	; For compatibility
                                 .equ	PORTE5	= 5	; 
                                 .equ	PE5	= 5	; For compatibility
                                 .equ	PORTE6	= 6	; 
                                 .equ	PE6	= 6	; For compatibility
                                 .equ	PORTE7	= 7	; 
                                 .equ	PE7	= 7	; For compatibility
                                 
                                 ; DDRE - Data Direction Register, Port E
                                 .equ	DDE0	= 0	; 
                                 .equ	DDE1	= 1	; 
                                 .equ	DDE2	= 2	; 
                                 .equ	DDE3	= 3	; 
                                 .equ	DDE4	= 4	; 
                                 .equ	DDE5	= 5	; 
                                 .equ	DDE6	= 6	; 
                                 .equ	DDE7	= 7	; 
                                 
                                 ; PINE - Input Pins, Port E
                                 .equ	PINE0	= 0	; 
                                 .equ	PINE1	= 1	; 
                                 .equ	PINE2	= 2	; 
                                 .equ	PINE3	= 3	; 
                                 .equ	PINE4	= 4	; 
                                 .equ	PINE5	= 5	; 
                                 .equ	PINE6	= 6	; 
                                 .equ	PINE7	= 7	; 
                                 
                                 
                                 ; ***** PORTF ************************
                                 ; PORTF - Data Register, Port F
                                 .equ	PORTF0	= 0	; 
                                 .equ	PF0	= 0	; For compatibility
                                 .equ	PORTF1	= 1	; 
                                 .equ	PF1	= 1	; For compatibility
                                 .equ	PORTF2	= 2	; 
                                 .equ	PF2	= 2	; For compatibility
                                 .equ	PORTF3	= 3	; 
                                 .equ	PF3	= 3	; For compatibility
                                 .equ	PORTF4	= 4	; 
                                 .equ	PF4	= 4	; For compatibility
                                 .equ	PORTF5	= 5	; 
                                 .equ	PF5	= 5	; For compatibility
                                 .equ	PORTF6	= 6	; 
                                 .equ	PF6	= 6	; For compatibility
                                 .equ	PORTF7	= 7	; 
                                 .equ	PF7	= 7	; For compatibility
                                 
                                 ; DDRF - Data Direction Register, Port F
                                 .equ	DDF0	= 0	; 
                                 .equ	DDF1	= 1	; 
                                 .equ	DDF2	= 2	; 
                                 .equ	DDF3	= 3	; 
                                 .equ	DDF4	= 4	; 
                                 .equ	DDF5	= 5	; 
                                 .equ	DDF6	= 6	; 
                                 .equ	DDF7	= 7	; 
                                 
                                 ; PINF - Input Pins, Port F
                                 .equ	PINF0	= 0	; 
                                 .equ	PINF1	= 1	; 
                                 .equ	PINF2	= 2	; 
                                 .equ	PINF3	= 3	; 
                                 .equ	PINF4	= 4	; 
                                 .equ	PINF5	= 5	; 
                                 .equ	PINF6	= 6	; 
                                 .equ	PINF7	= 7	; 
                                 
                                 
                                 ; ***** PORTG ************************
                                 ; PORTG - Data Register, Port G
                                 .equ	PORTG0	= 0	; 
                                 .equ	PG0	= 0	; For compatibility
                                 .equ	PORTG1	= 1	; 
                                 .equ	PG1	= 1	; For compatibility
                                 .equ	PORTG2	= 2	; 
                                 .equ	PG2	= 2	; For compatibility
                                 .equ	PORTG3	= 3	; 
                                 .equ	PG3	= 3	; For compatibility
                                 .equ	PORTG4	= 4	; 
                                 .equ	PG4	= 4	; For compatibility
                                 
                                 ; DDRG - Data Direction Register, Port G
                                 .equ	DDG0	= 0	; 
                                 .equ	DDG1	= 1	; 
                                 .equ	DDG2	= 2	; 
                                 .equ	DDG3	= 3	; 
                                 .equ	DDG4	= 4	; 
                                 
                                 ; PING - Input Pins, Port G
                                 .equ	PING0	= 0	; 
                                 .equ	PING1	= 1	; 
                                 .equ	PING2	= 2	; 
                                 .equ	PING3	= 3	; 
                                 .equ	PING4	= 4	; 
                                 
                                 
                                 ; ***** TIMER_COUNTER_0 **************
                                 ; TCCR0 - Timer/Counter Control Register
                                 .equ	CS00	= 0	; Clock Select 0
                                 .equ	CS01	= 1	; Clock Select 1
                                 .equ	CS02	= 2	; Clock Select 2
                                 .equ	WGM01	= 3	; Waveform Generation Mode 1
                                 .equ	CTC0	= WGM01	; For compatibility
                                 .equ	COM00	= 4	; Compare match Output Mode 0
                                 .equ	COM01	= 5	; Compare Match Output Mode 1
                                 .equ	WGM00	= 6	; Waveform Generation Mode 0
                                 .equ	PWM0	= WGM00	; For compatibility
                                 .equ	FOC0	= 7	; Force Output Compare
                                 
                                 ; TCNT0 - Timer/Counter Register
                                 .equ	TCNT0_0	= 0	; 
                                 .equ	TCNT0_1	= 1	; 
                                 .equ	TCNT0_2	= 2	; 
                                 .equ	TCNT0_3	= 3	; 
                                 .equ	TCNT0_4	= 4	; 
                                 .equ	TCNT0_5	= 5	; 
                                 .equ	TCNT0_6	= 6	; 
                                 .equ	TCNT0_7	= 7	; 
                                 
                                 ; OCR0 - Output Compare Register
                                 .equ	OCR0_0	= 0	; 
                                 .equ	OCR0_1	= 1	; 
                                 .equ	OCR0_2	= 2	; 
                                 .equ	OCR0_3	= 3	; 
                                 .equ	OCR0_4	= 4	; 
                                 .equ	OCR0_5	= 5	; 
                                 .equ	OCR0_6	= 6	; 
                                 .equ	OCR0_7	= 7	; 
                                 
                                 ; ASSR - Asynchronus Status Register
                                 .equ	TCR0UB	= 0	; Timer/Counter Control Register 0 Update Busy
                                 .equ	OCR0UB	= 1	; Output Compare register 0 Busy
                                 .equ	TCN0UB	= 2	; Timer/Counter0 Update Busy
                                 .equ	AS0	= 3	; Asynchronus Timer/Counter 0
                                 
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
                                 .equ	OCIE0	= 1	; Timer/Counter0 Output Compare Match Interrupt register
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag register
                                 .equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
                                 .equ	OCF0	= 1	; Output Compare Flag 0
                                 
                                 ; SFIOR - Special Function IO Register
                                 ;.equ	PSR0	= 1	; Prescaler Reset Timer/Counter0
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** TIMER_COUNTER_1 **************
                                 ; TIMSK - Timer/Counter Interrupt Mask Register
                                 .equ	TOIE1	= 2	; Timer/Counter1 Overflow Interrupt Enable
                                 .equ	OCIE1B	= 3	; Timer/Counter1 Output CompareB Match Interrupt Enable
                                 .equ	OCIE1A	= 4	; Timer/Counter1 Output CompareA Match Interrupt Enable
                                 .equ	TICIE1	= 5	; Timer/Counter1 Input Capture Interrupt Enable
                                 
                                 ; ETIMSK - Extended Timer/Counter Interrupt Mask Register
                                 .equ	OCIE1C	= 0	; Timer/Counter 1, Output Compare Match C Interrupt Enable
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag register
                                 .equ	TOV1	= 2	; Timer/Counter1 Overflow Flag
                                 .equ	OCF1B	= 3	; Output Compare Flag 1B
                                 .equ	OCF1A	= 4	; Output Compare Flag 1A
                                 .equ	ICF1	= 5	; Input Capture Flag 1
                                 
                                 ; ETIFR - Extended Timer/Counter Interrupt Flag register
                                 .equ	OCF1C	= 0	; Timer/Counter 1, Output Compare C Match Flag
                                 
                                 ; SFIOR - Special Function IO Register
                                 ;.equ	PSR321	= 0	; Prescaler Reset, T/C3, T/C2, T/C1
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 ; TCCR1A - Timer/Counter1 Control Register A
                                 .equ	WGM10	= 0	; Waveform Generation Mode Bit 0
                                 .equ	PWM10	= WGM10	; For compatibility
                                 .equ	WGM11	= 1	; Waveform Generation Mode Bit 1
                                 .equ	PWM11	= WGM11	; For compatibility
                                 .equ	COM1C0	= 2	; Compare Output Mode 1C, bit 0
                                 .equ	COM1C1	= 3	; Compare Output Mode 1C, bit 1
                                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                                 .equ	COM1A0	= 6	; Compare Ouput Mode 1A, bit 0
                                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 ; TCCR1B - Timer/Counter1 Control Register B
                                 .equ	CS10	= 0	; Clock Select bit 0
                                 .equ	CS11	= 1	; Clock Select 1 bit 1
                                 .equ	CS12	= 2	; Clock Select1 bit 2
                                 .equ	WGM12	= 3	; Waveform Generation Mode
                                 .equ	CTC10	= WGM12	; For compatibility
                                 .equ	WGM13	= 4	; Waveform Generation Mode
                                 .equ	CTC11	= WGM13	; For compatibility
                                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                                 
                                 ; TCCR1C - Timer/Counter1 Control Register C
                                 .equ	FOC1C	= 5	; Force Output Compare for channel C
                                 .equ	FOC1B	= 6	; Force Output Compare for channel B
                                 .equ	FOC1A	= 7	; Force Output Compare for channel A
                                 
                                 
                                 ; ***** TIMER_COUNTER_2 **************
                                 ; TCCR2 - Timer/Counter Control Register
                                 .equ	CS20	= 0	; Clock Select
                                 .equ	CS21	= 1	; Clock Select
                                 .equ	CS22	= 2	; Clock Select
                                 .equ	WGM21	= 3	; Waveform Generation Mode
                                 .equ	CTC2	= WGM21	; For compatibility
                                 .equ	COM20	= 4	; Compare Match Output Mode
                                 .equ	COM21	= 5	; Compare Match Output Mode
                                 .equ	WGM20	= 6	; Wafeform Generation Mode
                                 .equ	PWM2	= WGM20	; For compatibility
                                 .equ	FOC2	= 7	; Force Output Compare
                                 
                                 ; TCNT2 - Timer/Counter Register
                                 .equ	TCNT2_0	= 0	; Timer/Counter Register Bit 0
                                 .equ	TCNT2_1	= 1	; Timer/Counter Register Bit 1
                                 .equ	TCNT2_2	= 2	; Timer/Counter Register Bit 2
                                 .equ	TCNT2_3	= 3	; Timer/Counter Register Bit 3
                                 .equ	TCNT2_4	= 4	; Timer/Counter Register Bit 4
                                 .equ	TCNT2_5	= 5	; Timer/Counter Register Bit 5
                                 .equ	TCNT2_6	= 6	; Timer/Counter Register Bit 6
                                 .equ	TCNT2_7	= 7	; Timer/Counter Register Bit 7
                                 
                                 ; OCR2 - Output Compare Register
                                 .equ	OCR2_0	= 0	; Output Compare Register Bit 0
                                 .equ	OCR2_1	= 1	; Output Compare Register Bit 1
                                 .equ	OCR2_2	= 2	; Output Compare Register Bit 2
                                 .equ	OCR2_3	= 3	; Output Compare Register Bit 3
                                 .equ	OCR2_4	= 4	; Output Compare Register Bit 4
                                 .equ	OCR2_5	= 5	; Output Compare Register Bit 5
                                 .equ	OCR2_6	= 6	; Output Compare Register Bit 6
                                 .equ	OCR2_7	= 7	; Output Compare Register Bit 7
                                 
                                 ; TIMSK - 
                                 .equ	TOIE2	= 6	; 
                                 .equ	OCIE2	= 7	; 
                                 
                                 ; TIFR - Timer/Counter Interrupt Flag Register
                                 .equ	TOV2	= 6	; Timer/Counter2 Overflow Flag
                                 .equ	OCF2	= 7	; Output Compare Flag 2
                                 
                                 
                                 ; ***** TIMER_COUNTER_3 **************
                                 ; ETIMSK - Extended Timer/Counter Interrupt Mask Register
                                 .equ	OCIE3C	= 1	; Timer/Counter3, Output Compare Match Interrupt Enable
                                 .equ	TOIE3	= 2	; Timer/Counter3 Overflow Interrupt Enable
                                 .equ	OCIE3B	= 3	; Timer/Counter3 Output CompareB Match Interrupt Enable
                                 .equ	OCIE3A	= 4	; Timer/Counter3 Output CompareA Match Interrupt Enable
                                 .equ	TICIE3	= 5	; Timer/Counter3 Input Capture Interrupt Enable
                                 
                                 ; ETIFR - Extended Timer/Counter Interrupt Flag register
                                 .equ	OCF3C	= 1	; Timer/Counter3 Output Compare C Match Flag
                                 .equ	TOV3	= 2	; Timer/Counter3 Overflow Flag
                                 .equ	OCF3B	= 3	; Output Compare Flag 1B
                                 .equ	OCF3A	= 4	; Output Compare Flag 1A
                                 .equ	ICF3	= 5	; Input Capture Flag 1
                                 
                                 ; SFIOR - Special Function IO Register
                                 ;.equ	PSR321	= 0	; Prescaler Reset, T/C3, T/C2, T/C1
                                 ;.equ	PSR1	= PSR321	; For compatibility
                                 ;.equ	PSR2	= PSR321	; For compatibility
                                 ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 ; TCCR3A - Timer/Counter3 Control Register A
                                 .equ	WGM30	= 0	; Waveform Generation Mode Bit 0
                                 .equ	PWM30	= WGM30	; For compatibility
                                 .equ	WGM31	= 1	; Waveform Generation Mode Bit 1
                                 .equ	PWM31	= WGM31	; For compatibility
                                 .equ	COM3C0	= 2	; Compare Output Mode 3C, bit 0
                                 .equ	COM3C1	= 3	; Compare Output Mode 3C, bit 1
                                 .equ	COM3B0	= 4	; Compare Output Mode 3B, bit 0
                                 .equ	COM3B1	= 5	; Compare Output Mode 3B, bit 1
                                 .equ	COM3A0	= 6	; Comparet Ouput Mode 3A, bit 0
                                 .equ	COM3A1	= 7	; Compare Output Mode 3A, bit 1
                                 
                                 ; TCCR3B - Timer/Counter3 Control Register B
                                 .equ	CS30	= 0	; Clock Select 3 bit 0
                                 .equ	CS31	= 1	; Clock Select 3 bit 1
                                 .equ	CS32	= 2	; Clock Select3 bit 2
                                 .equ	WGM32	= 3	; Waveform Generation Mode
                                 .equ	CTC30	= WGM32	; For compatibility
                                 .equ	WGM33	= 4	; Waveform Generation Mode
                                 .equ	CTC31	= WGM33	; For compatibility
                                 .equ	ICES3	= 6	; Input Capture 3 Edge Select
                                 .equ	ICNC3	= 7	; Input Capture 3  Noise Canceler
                                 
                                 ; TCCR3C - Timer/Counter3 Control Register C
                                 .equ	FOC3C	= 5	; Force Output Compare for channel C
                                 .equ	FOC3B	= 6	; Force Output Compare for channel B
                                 .equ	FOC3A	= 7	; Force Output Compare for channel A
                                 
                                 ; TCNT3L - Timer/Counter3 Low Byte
                                 .equ	TCN3L0	= 0	; Timer/Counter 3 bit 0
                                 .equ	TCN3L1	= 1	; Timer/Counter 3 bit 1
                                 .equ	TCN3L2	= 2	; Timer/Counter 3 bit 2
                                 .equ	TCN3L3	= 3	; Timer/Counter 3 bit 3
                                 .equ	TCN3L4	= 4	; Timer/Counter 3 bit 4
                                 .equ	TCN3L5	= 5	; Timer/Counter 3 bit 5
                                 .equ	TCN3L6	= 6	; Timer/Counter 3 bit 6
                                 .equ	TCN3L7	= 7	; Timer/Counter 3 bit 7
                                 
                                 
                                 ; ***** WATCHDOG *********************
                                 ; WDTCR - Watchdog Timer Control Register
                                 .equ	WDTCSR	= WDTCR	; For compatibility
                                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                                 .equ	WDE	= 3	; Watch Dog Enable
                                 .equ	WDCE	= 4	; Watchdog Change Enable
                                 .equ	WDTOE	= WDCE	; For compatibility
                                 
                                 
                                 ; ***** AD_CONVERTER *****************
                                 ; ADMUX - The ADC multiplexer Selection Register
                                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                                 .equ	MUX4	= 4	; Analog Channel and Gain Selection Bits
                                 .equ	ADLAR	= 5	; Left Adjust Result
                                 .equ	REFS0	= 6	; Reference Selection Bit 0
                                 .equ	REFS1	= 7	; Reference Selection Bit 1
                                 
                                 ; ADCSRA - The ADC Control and Status register
                                 .equ	ADCSR	= ADCSRA	; For compatibility
                                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                                 .equ	ADIE	= 3	; ADC Interrupt Enable
                                 .equ	ADIF	= 4	; ADC Interrupt Flag
                                 .equ	ADFR	= 5	; ADC  Free Running Select
                                 .equ	ADSC	= 6	; ADC Start Conversion
                                 .equ	ADEN	= 7	; ADC Enable
                                 
                                 ; ADCH - ADC Data Register High Byte
                                 .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                                 .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                                 .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                                 .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                                 .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                                 .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                                 .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                                 .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                                 
                                 ; ADCL - ADC Data Register Low Byte
                                 .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                                 .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                                 .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                                 .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                                 .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                                 .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                                 .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                                 .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                                 
                                 
                                 
                                 ; ***** LOCKSBITS ********************************************************
                                 .equ	LB1	= 0	; Lock bit
                                 .equ	LB2	= 1	; Lock bit
                                 .equ	BLB01	= 2	; Boot Lock bit
                                 .equ	BLB02	= 3	; Boot Lock bit
                                 .equ	BLB11	= 4	; Boot lock bit
                                 .equ	BLB12	= 5	; Boot lock bit
                                 
                                 
                                 ; ***** FUSES ************************************************************
                                 ; LOW fuse bits
                                 .equ	CKSEL0	= 0	; Select Clock Source
                                 .equ	CKSEL1	= 1	; Select Clock Source
                                 .equ	CKSEL2	= 2	; Select Clock Source
                                 .equ	CKSEL3	= 3	; Select Clock Source
                                 .equ	SUT0	= 4	; Select start-up time
                                 .equ	SUT1	= 5	; Select start-up time
                                 .equ	BODEN	= 6	; Brown out detector enable
                                 .equ	BODLEVEL	= 7	; Brown out detector trigger level
                                 
                                 ; HIGH fuse bits
                                 .equ	BOOTRST	= 0	; Select Reset Vector
                                 .equ	BOOTSZ0	= 1	; Select Boot Size
                                 .equ	BOOTSZ1	= 2	; Select Boot Size
                                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                                 .equ	CKOPT	= 4	; Oscillator Options
                                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                                 .equ	JTAGEN	= 6	; Enable JTAG
                                 .equ	OCDEN	= 7	; Enable OCD
                                 
                                 ; EXTENDED fuse bits
                                 .equ	WDTON	= 0	; Watchdog timer always on
                                 .equ	M103C	= 1	; ATmega103 compatibility mode
                                 
                                 
                                 
                                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                                 .def	XH	= r27
                                 .def	XL	= r26
                                 .def	YH	= r29
                                 .def	YL	= r28
                                 .def	ZH	= r31
                                 .def	ZL	= r30
                                 
                                 
                                 
                                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                                 .equ	FLASHEND	= 0xffff	; Note: Word address
                                 .equ	IOEND	= 0x00ff
                                 .equ	SRAM_START	= 0x0100
                                 .equ	SRAM_SIZE	= 4096
                                 .equ	RAMEND	= 0x10ff
                                 .equ	XRAMEND	= 0xffff
                                 .equ	E2END	= 0x0fff
                                 .equ	EEPROMEND	= 0x0fff
                                 .equ	EEADRBITS	= 12
                                 #pragma AVRPART MEMORY PROG_FLASH 131072
                                 #pragma AVRPART MEMORY EEPROM 4096
                                 #pragma AVRPART MEMORY INT_SRAM SIZE 4096
                                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x100
                                 
                                 
                                 
                                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                                 .equ	NRWW_START_ADDR	= 0xf000
                                 .equ	NRWW_STOP_ADDR	= 0xffff
                                 .equ	RWW_START_ADDR	= 0x0
                                 .equ	RWW_STOP_ADDR	= 0xefff
                                 .equ	PAGESIZE	= 128
                                 .equ	FIRSTBOOTSTART	= 0xfe00
                                 .equ	SECONDBOOTSTART	= 0xfc00
                                 .equ	THIRDBOOTSTART	= 0xf800
                                 .equ	FOURTHBOOTSTART	= 0xf000
                                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                                 
                                 
                                 
                                 ; ***** INTERRUPT VECTORS ************************************************
                                 .equ	INT0addr	= 0x0002	; External Interrupt Request 0
                                 .equ	INT1addr	= 0x0004	; External Interrupt Request 1
                                 .equ	INT2addr	= 0x0006	; External Interrupt Request 2
                                 .equ	INT3addr	= 0x0008	; External Interrupt Request 3
                                 .equ	INT4addr	= 0x000a	; External Interrupt Request 4
                                 .equ	INT5addr	= 0x000c	; External Interrupt Request 5
                                 .equ	INT6addr	= 0x000e	; External Interrupt Request 6
                                 .equ	INT7addr	= 0x0010	; External Interrupt Request 7
                                 .equ	OC2addr	= 0x0012	; Timer/Counter2 Compare Match
                                 .equ	OVF2addr	= 0x0014	; Timer/Counter2 Overflow
                                 .equ	ICP1addr	= 0x0016	; Timer/Counter1 Capture Event
                                 .equ	OC1Aaddr	= 0x0018	; Timer/Counter1 Compare Match A
                                 .equ	OC1Baddr	= 0x001a	; Timer/Counter Compare Match B
                                 .equ	OVF1addr	= 0x001c	; Timer/Counter1 Overflow
                                 .equ	OC0addr	= 0x001e	; Timer/Counter0 Compare Match
                                 .equ	OVF0addr	= 0x0020	; Timer/Counter0 Overflow
                                 .equ	SPIaddr	= 0x0022	; SPI Serial Transfer Complete
                                 .equ	URXC0addr	= 0x0024	; USART0, Rx Complete
                                 .equ	UDRE0addr	= 0x0026	; USART0 Data Register Empty
                                 .equ	UTXC0addr	= 0x0028	; USART0, Tx Complete
                                 .equ	ADCCaddr	= 0x002a	; ADC Conversion Complete
                                 .equ	ERDYaddr	= 0x002c	; EEPROM Ready
                                 .equ	ACIaddr	= 0x002e	; Analog Comparator
                                 .equ	OC1Caddr	= 0x0030	; Timer/Counter1 Compare Match C
                                 .equ	ICP3addr	= 0x0032	; Timer/Counter3 Capture Event
                                 .equ	OC3Aaddr	= 0x0034	; Timer/Counter3 Compare Match A
                                 .equ	OC3Baddr	= 0x0036	; Timer/Counter3 Compare Match B
                                 .equ	OC3Caddr	= 0x0038	; Timer/Counter3 Compare Match C
                                 .equ	OVF3addr	= 0x003a	; Timer/Counter3 Overflow
                                 .equ	URXC1addr	= 0x003c	; USART1, Rx Complete
                                 .equ	UDRE1addr	= 0x003e	; USART1, Data Register Empty
                                 .equ	UTXC1addr	= 0x0040	; USART1, Tx Complete
                                 .equ	TWIaddr	= 0x0042	; 2-wire Serial Interface
                                 .equ	SPMRaddr	= 0x0044	; Store Program Memory Read
                                 
                                 .equ	INT_VECTORS_SIZE	= 70	; size in words
                                 
                                 #endif  /* _M128DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 ; purpose keypad 4x4 acquisition and print
                                 ; uses four external interrupts and ports internal pull-up
                                 
                                 ; solutions based on the methodology presented in EE208-MICRO210_ESP-2024-v1.0.fm
                                 ;>alternate solutions also possible
                                 ; standalone solution/file; not meant as a modular solution and thus must be
                                 ;>adapted when used in a complex project
                                 ; solution based on interrupts detected on each row; not optimal but functional if
                                 ;>and external four-input gate is not available
                                 
                                 ; RAM Allocation
                                 .dseg
000100                           current_code: .byte 1
000101                           correct_code: .byte 1
                                 .cseg
                                 
                                 .include "macros.asm"        ; include macro definitions
                                 
                                 ; purpose library, general-purpose macros
                                 ; author (c) R.Holzer (adapted MICRO210/EE208 A.Schmid)
                                 ; v2019.01 20180820 AxS
                                 
                                 ; ==============
                                 ; 	pointers
                                 ; ==============
                                 
                                 ; --- loading an immediate into a pointer XYZ,SP ---
                                 .macro 	LDIX	; sram
                                 	ldi	xl, low(@0)
                                 	ldi	xh,high(@0)
                                 	.endmacro	
                                 .macro 	LDIY	; sram	
                                 	ldi	yl, low(@0)
                                 	ldi	yh,high(@0)
                                 	.endmacro	
                                 .macro 	LDIZ	; sram
                                 	ldi	zl, low(@0)
                                 	ldi	zh,high(@0)
                                 	
                                 	.endmacro
                                 .macro	LDZD	; sram, reg	; sram+reg -> Z
                                 	mov	zl,@1
                                 	clr	zh
                                 	subi	zl, low(-@0)
                                 	sbci	zh,high(-@0)
                                 	.endmacro
                                 .macro	LDSP	; sram
                                 	ldi	r16, low(@0)
                                 	out	spl,r16
                                 	ldi	r16,high(@0)
                                 	out	sph,r16
                                 	.endmacro
                                 
                                 ; --- load/store SRAM addr into pointer XYZ ---	
                                 .macro 	LDSX	; sram
                                 	lds	xl,@0
                                 	lds	xh,@0+1
                                 	.endmacro
                                 .macro 	LDSY	; sram
                                 	lds	yl,@0
                                 	lds	yh,@0+1
                                 	.endmacro
                                 .macro 	LDSZ	; sram
                                 	lds	zl,@0
                                 	lds	zh,@0+1
                                 	.endmacro
                                 .macro 	STSX	; sram
                                 	sts	@0,  xl
                                 	sts	@0+1,xh
                                 	.endmacro	
                                 .macro 	STSY	; sram
                                 	sts	@0,  yl
                                 	sts	@0+1,yh
                                 	.endmacro
                                 .macro 	STSZ	; sram
                                 	sts	@0,  zl
                                 	sts	@0+1,zh
                                 	.endmacro	
                                 
                                 ; --- push/pop pointer XYZ ---
                                 .macro	PUSHX			; push X
                                 	push	xl
                                 	push	xh
                                 	.endmacro
                                 .macro	POPX			; pop X
                                 	pop	xh
                                 	pop	xl
                                 	.endmacro
                                 	
                                 .macro	PUSHY			; push Y
                                 	push	yl
                                 	push	yh
                                 	.endmacro
                                 .macro	POPY			; pop Y
                                 	pop	yh
                                 	pop	yl
                                 	.endmacro
                                 
                                 .macro	PUSHZ			; push Z
                                 	push	zl
                                 	push	zh
                                 	.endmacro
                                 .macro	POPZ			; pop Z
                                 	pop	zh
                                 	pop	zl
                                 	.endmacro
                                 
                                 ; --- multiply/divide Z ---	
                                 .macro	MUL2Z			; multiply Z by 2
                                 	lsl	zl
                                 	rol	zh
                                 	.endmacro
                                 .macro	DIV2Z			; divide Z by 2
                                 	lsr	zh
                                 	ror	zl
                                 	.endmacro
                                 
                                 ; --- add register to pointer XYZ ---	
                                 .macro	ADDX	;reg		; x <- y+reg
                                 	add	xl,@0
                                 	brcc	PC+2
                                 	subi	xh,-1		; add carry
                                 	.endmacro
                                 .macro	ADDY	;reg		; y <- y+reg
                                 	add	yl,@0
                                 	brcc	PC+2
                                 	subi	yh,-1		; add carry
                                 	.endmacro
                                 .macro	ADDZ	;reg		; z <- z+reg
                                 	add	zl,@0
                                 	brcc	PC+2
                                 	subi	zh,-1		; add carry
                                 	.endmacro
                                 
                                 ; ===================
                                 ; 	miscellaneous
                                 ; ===================
                                 
                                 ; --- output/store (regular I/O space) immediate value ---
                                 .macro	OUTI	; port,k	output immediate value to port
                                 	ldi	w,@1
                                 	out	@0,w
                                 	.endmacro
                                 
                                 ; --- output/store (extended I/O space) immediate value ---
                                 .macro OUTEI	; port,k    output immediate value to port
                                 	ldi	w,@1
                                 	sts	@0,w
                                 	.endmacro
                                 
                                 ; --- add immediate value ---
                                 .macro	ADDI
                                 	subi	@0,-@1
                                 	.endmacro
                                 .macro	ADCI
                                 	sbci	@0,-@1
                                 	.endmacro
                                 
                                 ; --- inc/dec with range limitation ---
                                 .macro	INC_LIM	; reg,limit
                                 	cpi	@0,@1
                                 	brlo	PC+3
                                 	ldi	@0,@1	
                                 	rjmp	PC+2
                                 	inc	@0
                                 	.endmacro
                                 
                                 .macro	DEC_LIM	; reg,limit
                                 	cpi	@0,@1
                                 	breq	PC+5
                                 	brlo	PC+3
                                 	dec	@0
                                 	rjmp	PC+2
                                 	ldi	@0,@1
                                 	.endmacro
                                 
                                 ; --- inc/dec with cyclic range ---
                                 .macro	INC_CYC	; reg,low,high
                                 	cpi	@0,@2
                                 	brsh	_low	; reg>=high then reg=low
                                 	cpi	@0,@1
                                 	brlo	_low	; reg< low  then reg=low
                                 	inc	@0
                                 	rjmp	_done
                                 _low:	ldi	@0,@1
                                 _done:	
                                     .endmacro
                                 	
                                 .macro	DEC_CYC	; reg,low,high
                                 	cpi	@0,@1
                                 	breq	_high	; reg=low then reg=high
                                 	brlo	_high	; reg<low then reg=high
                                 	dec	@0	
                                 	cpi	@0,@2
                                 	brsh	_high	; reg>=high then high
                                 	rjmp	_done
                                 _high:	ldi	@0,@2
                                 _done:	
                                 	.endmacro
                                 
                                 .macro	INCDEC	;port,b1,b2,reg,low,high
                                 	sbic	@0,@1
                                 	rjmp	PC+6
                                 
                                 	cpi	@3,@5
                                 	brlo	PC+3
                                 	ldi	@3,@4	
                                 	rjmp	PC+2
                                 	inc	@3
                                 
                                 	sbic	@0,@2
                                 	rjmp	PC+7
                                 	
                                 	cpi	@3,@4
                                 	breq	PC+5
                                 	brlo	PC+3
                                 	dec	@3
                                 	rjmp	PC+2
                                 	ldi	@3,@5
                                 	.endmacro		
                                 
                                 ; --- wait loops ---
                                 ; wait 10...196608 cycles
                                 .macro	WAIT_C	; k
                                 	ldi	w,  low((@0-7)/3)
                                 	mov	u,w			; u=LSB
                                 	ldi	w,high((@0-7)/3)+1	; w=MSB
                                 	dec	u
                                 	brne	PC-1
                                 	dec	u
                                 	dec	w
                                 	brne	PC-4
                                 	.endmacro
                                 
                                 ; wait micro-seconds (us)
                                 ; us = x*3*1000'000/clock)	==> x=us*clock/3000'000
                                 .macro	WAIT_US ; k
                                 	ldi	w, low((clock/1000*@0/3000)-1)
                                 	mov	u,w
                                 	ldi	w,high((clock/1000*@0/3000)-1)+1 ; set up: 3 cyles
                                 	dec	u
                                 	brne	PC-1		; inner loop: 3 cycles
                                 	dec	u		; adjustment for outer loop
                                 	dec	w
                                 	brne	PC-4
                                 	.endmacro
                                 
                                 ; wait mili-seconds (ms)
                                 .macro	WAIT_MS ; k
                                 	ldi	w, low(@0)
                                 	mov	u,w		; u = LSB	
                                 	ldi	w,high(@0)+1	; w = MSB
                                 wait_ms:
                                 	push	w		; wait 1000 usec
                                 	push	u
                                 	ldi	w, low((clock/3000)-5)	
                                 	mov	u,w
                                 	ldi	w,high((clock/3000)-5)+1
                                 	dec	u
                                 	brne	PC-1		; inner loop: 3 cycles
                                 	dec	u		; adjustment for outer loop
                                 	dec	w
                                 	brne	PC-4
                                 	pop	u
                                 	pop	w
                                 	
                                 	dec	u
                                 	brne	wait_ms
                                 	dec	w
                                 	brne	wait_ms
                                 	.endmacro
                                 
                                 ; --- conditional jumps/calls ---
                                 .macro	JC0			; jump if carry=0
                                 	brcs	PC+2	
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	JC1			; jump if carry=1
                                 	brcc	PC+2	
                                 	rjmp	@0
                                 	.endmacro
                                 
                                 .macro	JK	; reg,k,addr	; jump if reg=k
                                 	cpi	@0,@1
                                 	breq	@2
                                 	.endmacro
                                 .macro	_JK	; reg,k,addr	; jump if reg=k
                                 	cpi	@0,@1
                                 	brne	PC+2
                                 	rjmp	@2
                                 	.endmacro	
                                 .macro	JNK	; reg,k,addr	; jump if not(reg=k)
                                 	cpi	@0,@1
                                 	brne	@2
                                 	.endmacro 
                                 
                                 .macro	CK	; reg,k,addr	; call if reg=k
                                 	cpi	@0,@1
                                 	brne	PC+2
                                 	rcall	@2
                                 	.endmacro
                                 .macro	CNK	; reg,k,addr	; call if not(reg=k)
                                 	cpi	@0,@1
                                 	breq	PC+2
                                 	rcall	@2
                                 	.endmacro 
                                 
                                 .macro	JSK	; sram,k,addr	; jump if sram=k
                                 	lds	w,@0
                                 	cpi	w,@1
                                 	breq	@2
                                 	.endmacro 
                                 .macro	JSNK	; sram,k,addr	; jump if not(sram=k)
                                 	lds	w,@0
                                 	cpi	w,@1
                                 	brne	@2
                                 	.endmacro
                                 
                                 ; --- loops ---
                                 .macro	DJNZ	; reg,addr	; decr and jump if not zero
                                 	dec	@0
                                 	brne	@1
                                 	.endmacro
                                 .macro	DJNK	; reg,k,addr	; decr and jump if not k
                                 	dec	@0
                                 	cpi	@0,@1
                                 	brne	@2
                                 	.endmacro
                                 
                                 .macro	IJNZ	; reg,addr	; inc and jump if not zero
                                 	inc	@0
                                 	brne	@1
                                 	.endmacro
                                 .macro	IJNK	; reg,k,addr	; inc and jump if not k
                                 	inc	@0
                                 	cpi	@0,@1
                                 	brne	@2
                                 	.endmacro
                                 .macro	_IJNK	; reg,k,addr	; inc and jump if not k
                                 	inc	@0
                                 	ldi	w,@1
                                 	cp	@0,w
                                 	brne	@2
                                 	.endmacro
                                 
                                 .macro	ISJNK	; sram,k,addr	; inc sram and jump if not k
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	cpi	w,@1
                                 	brne	@2
                                 	.endmacro
                                 .macro	_ISJNK	; sram,k,addr	; inc sram and jump if not k
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	cpi	w,@1
                                 	breq	PC+2	
                                 	rjmp	@2
                                 	.endmacro
                                 
                                 .macro	DSJNK	; sram,k,addr	; dec sram and jump if not k
                                 	lds	w,@0
                                 	dec	w
                                 	sts	@0,w
                                 	cpi	w,@1
                                 	brne	@2
                                 	.endmacro
                                 
                                 ; --- table lookup ---
                                 .macro	LOOKUP	;reg, index,tbl
                                 	push	ZL
                                 	push	ZH
                                 	mov	zl,@1		; move index into z
                                 	clr	zh
                                 	subi	zl, low(-2*@2)	; add base address of table
                                 	sbci	zh,high(-2*@2)	
                                 	lpm			; load program memory (into r0)
                                 	mov	@0,r0
                                 	pop	ZH
                                 	pop	ZL
                                 	.endmacro
                                 
                                 .macro	LOOKUP2	;r1,r0, index,tbl
                                 	mov	zl,@2		; move index into z
                                 	clr	zh
                                 	lsl	zl		; multiply by 2
                                 	rol	zh
                                 	subi	zl, low(-2*@3)	; add base address of table
                                 	sbci	zh,high(-2*@3)
                                 	lpm			; get LSB byte
                                 	mov	w,r0		; temporary store LSB in w
                                 	adiw	zl,1		; increment Z
                                 	lpm			; get MSB byte
                                 	mov	@0,r0		; mov MSB to res1
                                 	mov	@1,w		; mov LSB to res0
                                 	.endmacro
                                 
                                 .macro	LOOKUP4	;r3,r2,r1,r0, index,tbl
                                 	mov	zl,@4		; move index into z
                                 	clr	zh
                                 	lsl	zl		; multiply by 2
                                 	rol	zh
                                 	lsl	zl		; multiply by 2
                                 	rol	zh	
                                 	subi	zl, low(-2*@5)	; add base address of table
                                 	sbci	zh,high(-2*@5)
                                 	lpm
                                 	mov	@1,r0		; load high word LSB
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@0,r0		; load high word MSB
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@3,r0		; load low word LSB		
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@2,r0		; load low word MSB
                                 	.endmacro
                                 
                                 .macro	LOOKDOWN ;reg,index,tbl
                                 	ldi	ZL, low(2*@2)	; load table address
                                 	ldi	ZH,high(2*@2)
                                 	clr	@1
                                 loop:	lpm
                                 	cp	r0,@0
                                 	breq	found
                                 	inc	@1
                                 	adiw	ZL,1
                                 	tst	r0
                                 	breq	notfound
                                 	rjmp	loop
                                 notfound:
                                 	ldi	@1,-1
                                 found:	
                                 	.endmacro
                                 
                                 ; --- branch table ---
                                 .macro	C_TBL	; reg,tbl
                                 	ldi	ZL, low(2*@1)
                                 	ldi	ZH,high(2*@1)
                                 	lsl	@0
                                 	add	ZL,@0
                                 	brcc	PC+2
                                 	inc	ZH
                                 	lpm
                                 	push	r0
                                 	lpm
                                 	mov	zh,r0
                                 	pop	zl
                                 	icall
                                 	.endmacro
                                 .macro	J_TBL	; reg,tbl	
                                 	ldi	ZL, low(2*@1)
                                 	ldi	ZH,high(2*@1)
                                 	lsl	@0
                                 	add	ZL,@0
                                 	brcc	PC+2
                                 	inc	ZH
                                 	lpm
                                 	push	r0
                                 	lpm
                                 	mov	zh,r0
                                 	pop	zl	
                                 	ijmp
                                 	.endmacro
                                 
                                 .macro	BRANCH	; reg		; branching using the stack
                                 	ldi	w, low(tbl)
                                 	add	w,@0
                                 	push	w
                                 	ldi	w,high(tbl)
                                 	brcc	PC+2
                                 	inc	w
                                 	push	w
                                 	ret
                                 tbl:
                                 	.endmacro	
                                 
                                 ; --- multiply/division ---
                                 .macro	DIV2	; reg
                                 	lsr	@0
                                 	.endmacro
                                 .macro	DIV4	; reg
                                 	lsr	@0
                                 	lsr	@0
                                 	.endmacro	
                                 .macro	DIV8	; reg
                                 	lsr	@0
                                 	lsr	@0
                                 	lsr	@0
                                 	.endmacro
                                 	
                                 .macro	MUL2	; reg
                                 	lsl	@0
                                 	.endmacro
                                 .macro	MUL4	; reg
                                 	lsl	@0
                                 	lsl	@0
                                 	.endmacro
                                 .macro	MUL8	; reg
                                 	lsl	@0
                                 	lsl	@0
                                 	lsl	@0
                                 	.endmacro
                                 
                                 ; ====================================
                                 ; 	extending existing instructios
                                 ; ====================================
                                 
                                 ; --- immediate ops with r0..r15 ---
                                 .macro	_ADDI
                                 	ldi	w,@1
                                 	add	@0,w
                                 	.endmacro
                                 .macro	_ADCI
                                 	ldi	w,@1
                                 	adc	@0,w
                                 	.endmacro
                                 .macro	_SUBI
                                 	ldi	w,@1
                                 	sub	@0,w
                                 	.endmacro
                                 .macro	_SBCI
                                 	ldi	w,@1
                                 	sbc	@0,w
                                 	.endmacro
                                 .macro	_ANDI
                                 	ldi	w,@1
                                 	and	@0,w
                                 	.endmacro
                                 .macro	_ORI
                                 	ldi	w,@1
                                 	or	@0,w
                                 	.endmacro
                                 .macro	_EORI
                                 	ldi	w,@1
                                 	eor	@0,w
                                 	.endmacro
                                 .macro	_SBR
                                 	ldi	w,@1
                                 	or	@0,w
                                 	.endmacro
                                 .macro	_CBR
                                 	ldi	w,~@1
                                 	and	@0,w
                                 	.endmacro
                                 .macro	_CPI
                                 	ldi	w,@1
                                 	cp	@0,w
                                 	.endmacro
                                 .macro	_LDI
                                 	ldi	w,@1
                                 	mov	@0,w
                                 	.endmacro
                                 
                                 ; --- bit access for port p32..p63 ---
                                 .macro	_SBI
                                 	in	w,@0
                                 	ori	w,1<<@1
                                 	out	@0,w
                                 	.endmacro
                                 .macro	_CBI
                                 	in	w,@0
                                 	andi	w,~(1<<@1)
                                 	out	@0,w
                                 	.endmacro
                                 	
                                 ; --- extending branch distance to +/-2k ---
                                 .macro	_BREQ
                                 	brne	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRNE
                                 	breq	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRCS
                                 	brcc	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRCC
                                 	brcs	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRSH
                                 	brlo	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRLO
                                 	brsh	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRMI
                                 	brpl	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRPL
                                 	brmi	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRGE
                                 	brlt	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRLT
                                 	brge	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRHS
                                 	brhc	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRHC
                                 	brhs	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRTS
                                 	brtc	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRTC
                                 	brts	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRVS
                                 	brvc	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRVC
                                 	brvs	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRIE
                                 	brid	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	_BRID
                                 	brie	PC+2
                                 	rjmp	@0
                                 	.endmacro
                                 
                                 ; ====================
                                 ; 	bit operations
                                 ; ====================
                                 
                                 ; --- moving bits ---
                                 .macro	MOVB	; reg1,b1, reg2,b2	; reg1,bit1 <- reg2,bit2
                                 	bst	@2,@3
                                 	bld	@0,@1
                                 	.endmacro
                                 .macro	OUTB	; port1,b1, reg2,b2	; port1,bit1 <- reg2,bit2
                                 	sbrs	@2,@3
                                 	cbi	@0,@1
                                 	sbrc	@2,@3
                                 	sbi	@0,@1
                                 	.endmacro
                                 .macro	INB	; reg1,b1, port2,b2	; reg1,bit1 <- port2,bit2
                                 	sbis	@2,@3
                                 	cbr	@0,1<<@1
                                 	sbic	@2,@3
                                 	sbr	@0,1<<@1
                                 	.endmacro
                                 
                                 .macro	Z2C				; zero to carry
                                 	sec
                                 	breq	PC+2	; (Z=1)
                                 	clc
                                 	.endmacro
                                 .macro	Z2INVC				; zero to inverse carry
                                 	sec
                                 	brne	PC+2	; (Z=0)
                                 	clc
                                 	.endmacro
                                 
                                 .macro	C2Z				; carry to zero
                                 	sez
                                 	brcs	PC+2	; (C=1)
                                 	clz
                                 	.endmacro
                                 
                                 .macro	B2C	; reg,b			; bit to carry
                                 	sbrc	@0,@1
                                 	sec
                                 	sbrs	@0,@1
                                 	clc
                                 	.endmacro
                                 .macro	C2B	; reg,b			; carry to bit
                                 	brcc	PC+2
                                 	sbr	@0,(1<<@1)
                                 	brcs	PC+2
                                 	cbr	@0,(1<<@1)
                                 	.endmacro
                                 .macro	P2C	; port,b		; port to carry
                                 	sbic	@0,@1
                                 	sec
                                 	sbis	@0,@1
                                 	clc
                                 	.endmacro
                                 .macro	C2P	; port,b		; carry to port
                                 	brcc	PC+2
                                 	sbi	@0,@1
                                 	brcs	PC+2
                                 	cbi	@0,@1
                                 	.endmacro
                                 
                                 ; --- inverting bits ---
                                 .macro	INVB	; reg,bit		; inverse reg,bit
                                 	ldi	w,(1<<@1)
                                 	eor	@0,w
                                 	.endmacro
                                 .macro	INVP	; port,bit		; inverse port,bit	
                                 	sbis	@0,@1
                                 	rjmp	PC+3
                                 	cbi	@0,@1
                                 	rjmp	PC+2
                                 	sbi	@0,@1
                                 	.endmacro
                                 .macro	INVC				; inverse carry	
                                 	brcs	PC+3
                                 	sec
                                 	rjmp	PC+2
                                 	clc
                                 	.endmacro
                                 
                                 ; --- setting a single bit ---
                                 .macro	SETBIT	; reg(0..7)
                                 ; in	reg (0..7)
                                 ; out	reg with bit (0..7) set to 1.
                                 ; 0=00000001
                                 ; 1=00000010
                                 ; ...
                                 ; 7=10000000
                                 	mov	w,@0
                                 	clr	@0
                                 	inc	@0
                                 	andi	w,0b111	
                                 	breq	PC+4
                                 	lsl	@0
                                 	dec	w
                                 	brne	PC-2
                                 	.endmacro
                                 
                                 ; --- logical operations with masks ---
                                 .macro	MOVMSK	; reg1,reg2,mask	; reg1 <- reg2 (mask)
                                 	ldi	w,~@2	
                                 	and	@0,w
                                 	ldi	w,@2
                                 	and	@1,w	
                                 	or	@0,@1
                                 	.endmacro	
                                 .macro	ANDMSK	; reg1,reg2,mask	; reg1 <- ret 1 AND reg2 (mask)		
                                 	mov	w,@1
                                 	ori	w,~@2
                                 	and	@0,w
                                 	.endmacro	
                                 .macro	ORMSK	; reg1,reg2,mask	; reg1 <- ret 1 AND reg2 (mask)		
                                 	mov	w,@1
                                 	andi	w,@2
                                 	or	@0,w
                                 	.endmacro
                                 	
                                 ; --- logical operations on bits ---
                                 .macro	ANDB	; r1,b1, r2,b2, r3,b3	; reg1,b1 <- reg2,b2 AND reg3,b3
                                 	set
                                 	sbrs	@4,@5	
                                 	clt
                                 	sbrs	@2,@3	
                                 	clt
                                 	bld	@0,@1
                                 	.endmacro
                                 .macro	ORB	; r1,b1, r2,b2, r3,b3	; reg1.b1 <- reg2.b2 OR reg3.b3
                                 	clt
                                 	sbrc	@4,@5	
                                 	set
                                 	sbrc	@2,@3	
                                 	set
                                 	bld	@0,@1
                                 	.endmacro
                                 .macro	EORB	; r1,b1, r2,b2, r3,b3	; reg1.b1 <- reg2.b2 XOR reg3.b3
                                 	sbrc	@4,@5
                                 	rjmp	f1
                                 f0:	bst	@2,@3	
                                 	rjmp	PC+4
                                 f1:	set
                                 	sbrc	@0,@1
                                 	clt
                                 	bld	@0,@0	
                                 	.endmacro
                                 	
                                 ; --- operations based on register bits ---
                                 .macro	FB0	; reg,bit		; bit=0
                                 	cbr	@0,1<<@1
                                 	.endmacro
                                 .macro	FB1	; reg,bit		; bit=1
                                 	sbr	@0,1<<@1
                                 	.endmacro
                                 .macro	_FB0	; reg,bit		; bit=0
                                 	ldi	w,~(1<<@1)
                                 	and	@0,w
                                 	.endmacro
                                 .macro	_FB1	; reg,bit		; bit=1
                                 	ldi	w,1<<@1
                                 	or	@0,w
                                 	.endmacro
                                 .macro	SB0	; reg,bit,addr		; skip if bit=0
                                 	sbrc	@0,@1
                                 	.endmacro
                                 .macro	SB1	; reg,bit,addr		; skip if bit=1
                                 	sbrs	@0,@1
                                 	.endmacro
                                 .macro	JB0	; reg,bit,addr		; jump if bit=0
                                 	sbrs	@0,@1
                                 	rjmp	@2
                                 	.endmacro
                                 .macro	JB1	; reg,bit,addr		; jump if bit=1
                                 	sbrc	@0,@1
                                 	rjmp	@2
                                 	.endmacro
                                 .macro	CB0	; reg,bit,addr		; call if bit=0
                                 	sbrs	@0,@1
                                 	rcall	@2
                                 	.endmacro
                                 .macro	CB1	; reg,bit,addr		; call if bit=1
                                 	sbrc	@0,@1
                                 	rcall	@2
                                 	.endmacro
                                 .macro	WB0	; reg,bit		; wait if bit=0
                                 	sbrs	@0,@1
                                 	rjmp	PC-1
                                 	.endmacro
                                 .macro	WB1	; reg,bit		; wait if bit=1
                                 	sbrc	@0,@1
                                 	rjmp	PC-1
                                 	.endmacro
                                 .macro	RB0	; reg,bit		; return if bit=0
                                 	sbrs	@0,@1
                                 	ret
                                 	.endmacro
                                 .macro	RB1	; reg,bit		; return if bit=1
                                 	sbrc	@0,@1
                                 	ret
                                 	.endmacro
                                 
                                 ; wait if bit=0 with timeout
                                 ; if timeout (in units of 5 cyc) then jump to addr
                                 .macro	WB0T	; reg,bit,timeout,addr
                                 	ldi	w,@2+1
                                 	dec	w	; 1 cyc
                                 	breq	@3	; 1 cyc
                                 	sbrs	@0,@1	; 1 cyc
                                 	rjmp	PC-3	; 2 cyc = 5 cycles
                                 	.endmacro
                                 
                                 ; wait if bit=1 with timeout
                                 ; if timeout (in units of 5 cyc) then jump to addr	
                                 .macro	WB1T	; reg,bit,timeout,addr
                                 	ldi	w,@2+1
                                 	dec	w	; 1 cyc
                                 	breq	@3	; 1 cyc
                                 	sbrc	@0,@1	; 1 cyc
                                 	rjmp	PC-3	; 2 cyc = 5 cycles
                                 	.endmacro	
                                 	
                                 ; --- operations based on port bits ---
                                 .macro	P0	; port,bit		; port=0
                                 	cbi	@0,@1
                                 	.endmacro
                                 .macro	P1	; port,bit		; port=1
                                 	sbi	@0,@1
                                 	.endmacro
                                 .macro	SP0	; port,bit		; skip if port=0
                                 	sbic	@0,@1
                                 	.endmacro
                                 .macro	SP1	; port,bit		; skip if port=1
                                 	sbis	@0,@1
                                 	.endmacro
                                 .macro	JP0	; port,bit,addr		; jump if port=0
                                 	sbis	@0,@1
                                 	rjmp	@2
                                 	.endmacro
                                 .macro	JP1	; port,bit,addr		; jump if port=1
                                 	sbic	@0,@1
                                 	rjmp	@2
                                 	.endmacro
                                 .macro	CP0	; port,bit,addr		; call if port=0
                                 	sbis	@0,@1
                                 	rcall	@2
                                 	.endmacro
                                 .macro	CP1	; port,bit,addr		; call if port=1
                                 	sbic	@0,@1
                                 	rcall	@2
                                 	.endmacro
                                 .macro	WP0	; port,bit		; wait if port=0
                                 	sbis	@0,@1
                                 	rjmp	PC-1
                                 	.endmacro
                                 .macro	WP1	; port,bit		; wait if port=1
                                 	sbic	@0,@1
                                 	rjmp	PC-1
                                 	.endmacro
                                 .macro	RP0	; port,bit		; return if port=0
                                 	sbis	@0,@1
                                 	ret
                                 	.endmacro
                                 .macro	RP1	; port,bit		; return if port=1
                                 	sbic	@0,@1
                                 	ret
                                 	.endmacro
                                 
                                 ; wait if port=0 with timeout
                                 ; if timeout (in units of 5 cyc) then jump to addr
                                 .macro	WP0T	; port,bit,timeout,addr
                                 	ldi	w,@2+1
                                 	dec	w	; 1 cyc
                                 	breq	@3	; 1 cyc
                                 	sbis	@0,@1	; 1 cyc
                                 	rjmp	PC-3	; 2 cyc = 5 cycles
                                 	.endmacro
                                 
                                 ; wait if port=1 with timeout
                                 ; if timeout (in units of 5 cyc) then jump to addr	
                                 .macro	WP1T	; port,bit,timeout,addr
                                 	ldi	w,@2+1
                                 	dec	w	; 1 cyc
                                 	breq	@3	; 1 cyc
                                 	sbic	@0,@1	; 1 cyc
                                 	rjmp	PC-3	; 2 cyc = 5 cycles
                                 	.endmacro	
                                 
                                 ; ===========================
                                 ; 	multi-byte operations
                                 ; ===========================
                                 
                                 .macro	SWAP4			; swap 2 variables
                                 	mov	w ,@0
                                 	mov	@0,@4
                                 	mov	@4,w
                                 	mov	w ,@1
                                 	mov	@1,@5
                                 	mov	@5,w
                                 	mov	w ,@2
                                 	mov	@2,@6
                                 	mov	@6,w
                                 	mov	w ,@3
                                 	mov	@3,@7
                                 	mov	@7,w
                                 	.endmacro
                                 .macro	SWAP3
                                 	mov	w ,@0
                                 	mov	@0,@3
                                 	mov	@3,w
                                 	mov	w ,@1
                                 	mov	@1,@4
                                 	mov	@4,w
                                 	mov	w ,@2
                                 	mov	@2,@5
                                 	mov	@5,w
                                 	.endmacro
                                 .macro	SWAP2
                                 	mov	w ,@0
                                 	mov	@0,@2
                                 	mov	@2,w
                                 	mov	w ,@1
                                 	mov	@1,@3
                                 	mov	@3,w
                                 	.endmacro
                                 .macro	SWAP1
                                 	mov	w ,@0
                                 	mov	@0,@1
                                 	mov	@1,w
                                 	.endmacro
                                 
                                 .macro	LDX4	;r..r0		; load from (x+)
                                 	ld	@3,x+
                                 	ld	@2,x+	
                                 	ld	@1,x+
                                 	ld	@0,x+
                                 	.endmacro
                                 .macro	LDX3	;r..r0
                                 	ld	@2,x+	
                                 	ld	@1,x+
                                 	ld	@0,x+
                                 	.endmacro
                                 .macro	LDX2	;r..r0	
                                 	ld	@1,x+
                                 	ld	@0,x+
                                 	.endmacro
                                 	
                                 .macro	LDY4	;r..r0		; load from (y+)
                                 	ld	@3,y+
                                 	ld	@2,y+	
                                 	ld	@1,y+
                                 	ld	@0,y+
                                 	.endmacro
                                 .macro	LDY3	;r..r0
                                 	ld	@2,y+	
                                 	ld	@1,y+
                                 	ld	@0,y+
                                 	.endmacro
                                 .macro	LDY2	;r..r0	
                                 	ld	@1,y+
                                 	ld	@0,y+
                                 	.endmacro
                                 
                                 .macro	LDZ4	;r..r0		; load from (z+)
                                 	ld	@3,z+
                                 	ld	@2,z+	
                                 	ld	@1,z+
                                 	ld	@0,z+
                                 	.endmacro
                                 .macro	LDZ3	;r..r0
                                 	ld	@2,z+	
                                 	ld	@1,z+
                                 	ld	@0,z+
                                 	.endmacro
                                 .macro	LDZ2	;r..r0
                                 	ld	@1,z+
                                 	ld	@0,z+
                                 	.endmacro
                                 
                                 .macro	STX4	;r..r0		; store to (x+)
                                 	st	x+,@3
                                 	st	x+,@2	
                                 	st	x+,@1
                                 	st	x+,@0
                                 	.endmacro
                                 .macro	STX3	;r..r0
                                 	st	x+,@2	
                                 	st	x+,@1
                                 	st	x+,@0
                                 	.endmacro
                                 .macro	STX2	;r..r0
                                 	st	x+,@1
                                 	st	x+,@0
                                 	.endmacro
                                 	
                                 .macro	STY4	;r..r0		; store to (y+)
                                 	st	y+,@3
                                 	st	y+,@2	
                                 	st	y+,@1
                                 	st	y+,@0
                                 	.endmacro
                                 .macro	STY3	;r..r0
                                 	st	y+,@2	
                                 	st	y+,@1
                                 	st	y+,@0
                                 	.endmacro
                                 .macro	STY2	;r..r0	
                                 	st	y+,@1
                                 	st	y+,@0
                                 	.endmacro
                                 	
                                 .macro	STZ4	;r..r0		; store to (z+)
                                 	st	z+,@3
                                 	st	z+,@2	
                                 	st	z+,@1
                                 	st	z+,@0
                                 	.endmacro	
                                 .macro	STZ3	;r..r0
                                 	st	z+,@2	
                                 	st	z+,@1
                                 	st	z+,@0
                                 	.endmacro	
                                 .macro	STZ2	;r..r0	
                                 	st	z+,@1
                                 	st	z+,@0
                                 	.endmacro	
                                 	
                                 .macro	STI4	;addr,k		; store immediate
                                 	ldi	w,  low(@1)
                                 	sts	@0+0,w
                                 	ldi	w, high(@1)
                                 	sts	@0+1,w
                                 	ldi	w,byte3(@1)
                                 	sts	@0+2,w
                                 	ldi	w,byte4(@1)
                                 	sts	@0+3,w	
                                 	.endmacro	
                                 .macro	STI3	;addr,k
                                 	ldi	w,  low(@1)
                                 	sts	@0+0,w
                                 	ldi	w, high(@1)
                                 	sts	@0+1,w
                                 	ldi	w,byte3(@1)
                                 	sts	@0+2,w
                                 	.endmacro	
                                 .macro	STI2	;addr,k
                                 	ldi	w,  low(@1)
                                 	sts	@0+0,w
                                 	ldi	w, high(@1)
                                 	sts	@0+1,w
                                 	.endmacro
                                 .macro	STI	;addr,k
                                 	ldi	w,@1
                                 	sts	@0,w
                                 	.endmacro
                                 
                                 .macro	INC4			; increment
                                 	ldi	w,0xff
                                 	sub	@3,w
                                 	sbc	@2,w
                                 	sbc	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 .macro	INC3
                                 	ldi	w,0xff
                                 	sub	@2,w
                                 	sbc	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 .macro	INC2
                                 	ldi	w,0xff
                                 	sub	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 
                                 .macro	DEC4			; decrement
                                 	ldi	w,0xff
                                 	add	@3,w
                                 	adc	@2,w
                                 	adc	@1,w
                                 	adc	@0,w
                                 	.endmacro
                                 .macro	DEC3
                                 	ldi	w,0xff
                                 	add	@2,w
                                 	adc	@1,w
                                 	adc	@0,w
                                 	.endmacro
                                 .macro	DEC2
                                 	ldi	w,0xff
                                 	add	@1,w
                                 	adc	@0,w
                                 	.endmacro
                                 
                                 .macro	CLR9			; clear (also clears the carry)
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	clr	@4
                                 	clr	@5
                                 	clr	@6
                                 	clr	@7
                                 	clr	@8
                                 	.endmacro
                                 .macro	CLR8
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	clr	@4
                                 	clr	@5
                                 	clr	@6
                                 	clr	@7
                                 	.endmacro
                                 .macro	CLR7
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	clr	@4
                                 	clr	@5
                                 	clr	@6
                                 	.endmacro
                                 .macro	CLR6
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	clr	@4
                                 	clr	@5
                                 	.endmacro
                                 .macro	CLR5
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	clr	@4
                                 	.endmacro
                                 .macro	CLR4
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	clr	@3
                                 	.endmacro
                                 .macro	CLR3
                                 	sub	@0,@0
                                 	clr	@1
                                 	clr	@2
                                 	.endmacro
                                 .macro	CLR2
                                 	sub	@0,@0
                                 	clr	@1
                                 	.endmacro
                                 
                                 .macro	COM4			; one's complement
                                 	com	@0
                                 	com	@1
                                 	com	@2
                                 	com	@3
                                 	.endmacro
                                 .macro	COM3
                                 	com	@0
                                 	com	@1
                                 	com	@2
                                 	.endmacro
                                 .macro	COM2
                                 	com	@0
                                 	com	@1
                                 	.endmacro
                                 
                                 .macro	NEG4			; negation (two's complement)
                                 	com	@0
                                 	com	@1
                                 	com	@2
                                 	com	@3
                                 	ldi	w,0xff
                                 	sub	@3,w
                                 	sbc	@2,w
                                 	sbc	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 .macro	NEG3
                                 	com	@0
                                 	com	@1
                                 	com	@2
                                 	ldi	w,0xff
                                 	sub	@2,w
                                 	sbc	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 .macro	NEG2
                                 	com	@0
                                 	com	@1
                                 	ldi	w,0xff
                                 	sub	@1,w
                                 	sbc	@0,w
                                 	.endmacro
                                 	
                                 .macro	LDI4 	; r..r0, k	; load immediate
                                 	ldi	@3,  low(@4)
                                 	ldi	@2, high(@4)
                                 	ldi	@1,byte3(@4)
                                 	ldi	@0,byte4(@4)
                                 	.endmacro
                                 .macro	LDI3
                                 	ldi	@2,  low(@3)
                                 	ldi	@1, high(@3)
                                 	ldi	@0,byte3(@3)
                                 	.endmacro
                                 .macro	LDI2
                                 	ldi	@1,  low(@2)
                                 	ldi	@0, high(@2)
                                 	.endmacro
                                 
                                 .macro	LDS4			; load direct from SRAM
                                 	lds	@3,@4
                                 	lds	@2,@4+1
                                 	lds	@1,@4+2
                                 	lds	@0,@4+3
                                 	.endmacro
                                 .macro	LDS3
                                 	lds	@2,@3
                                 	lds	@1,@3+1
                                 	lds	@0,@3+2
                                 	.endmacro
                                 .macro	LDS2
                                 	lds	@1,@2
                                 	lds	@0,@2+1
                                 	.endmacro
                                 
                                 .macro	STS4			; store direct to SRAM
                                 	sts	@0+0,@4
                                 	sts	@0+1,@3
                                 	sts	@0+2,@2
                                 	sts	@0+3,@1
                                 	.endmacro
                                 .macro	STS3
                                 	sts	@0+0,@3
                                 	sts	@0+1,@2
                                 	sts	@0+2,@1
                                 	.endmacro
                                 .macro	STS2
                                 	sts	@0+0,@2
                                 	sts	@0+1,@1
                                 	.endmacro
                                 
                                 .macro	STDZ4	; d, r3,r2,r1,r0
                                 	std	z+@0+0,@4
                                 	std	z+@0+1,@3
                                 	std	z+@0+2,@2
                                 	std	z+@0+3,@1
                                 	.endmacro
                                 .macro	STDZ3	; d, r2,r1,r0
                                 	std	z+@0+0,@3
                                 	std	z+@0+1,@2
                                 	std	z+@0+2,@1
                                 	.endmacro
                                 .macro	STDZ2	; d, r1,r0
                                 	std	z+@0+0,@2
                                 	std	z+@0+1,@1
                                 	.endmacro
                                 	
                                 .macro	LPM4			; load program memory
                                 	lpm
                                 	mov	@3,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@2,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@1,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@0,r0
                                 	adiw	zl,1
                                 	.endmacro
                                 .macro	LPM3
                                 	lpm
                                 	mov	@2,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@1,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@0,r0
                                 	adiw	zl,1
                                 	.endmacro
                                 .macro	LPM2
                                 	lpm
                                 	mov	@1,r0
                                 	adiw	zl,1
                                 	lpm
                                 	mov	@0,r0
                                 	adiw	zl,1
                                 	.endmacro
                                 .macro	LPM1
                                 	lpm
                                 	mov	@0,r0
                                 	adiw	zl,1
                                 	.endmacro
                                 
                                 .macro	MOV4			; move between registers
                                 	mov	@3,@7
                                 	mov	@2,@6
                                 	mov	@1,@5
                                 	mov	@0,@4
                                 	.endmacro
                                 .macro	MOV3
                                 	mov	@2,@5
                                 	mov	@1,@4
                                 	mov	@0,@3
                                 	.endmacro
                                 .macro	MOV2
                                 	mov	@1,@3
                                 	mov	@0,@2
                                 	.endmacro
                                 
                                 .macro	ADD4			; add
                                 	add	@3,@7
                                 	adc	@2,@6
                                 	adc	@1,@5
                                 	adc	@0,@4
                                 	.endmacro
                                 .macro	ADD3
                                 	add	@2,@5
                                 	adc	@1,@4
                                 	adc	@0,@3
                                 	.endmacro
                                 .macro	ADD2
                                 	add	@1,@3
                                 	adc	@0,@2
                                 	.endmacro
                                 
                                 .macro	SUB4			; subtract
                                 	sub	@3,@7
                                 	sbc	@2,@6
                                 	sbc	@1,@5
                                 	sbc	@0,@4
                                 	.endmacro
                                 .macro	SUB3
                                 	sub	@2,@5
                                 	sbc	@1,@4
                                 	sbc	@0,@3
                                 	.endmacro
                                 .macro	SUB2
                                 	sub	@1,@3
                                 	sbc	@0,@2
                                 	.endmacro
                                 	
                                 .macro	CP4			; compare
                                 	cp	@3,@7
                                 	cpc	@2,@6
                                 	cpc	@1,@5
                                 	cpc	@0,@4
                                 	.endmacro
                                 .macro	CP3
                                 	cp	@2,@5
                                 	cpc	@1,@4
                                 	cpc	@0,@3
                                 	.endmacro
                                 .macro	CP2
                                 	cp	@1,@3
                                 	cpc	@0,@2
                                 	.endmacro
                                 
                                 .macro	TST4			; test
                                 	clr	w
                                 	cp	@3,w
                                 	cpc	@2,w
                                 	cpc	@1,w
                                 	cpc	@0,w
                                 	.endmacro
                                 .macro	TST3
                                 	clr	w
                                 	cp	@2,w
                                 	cpc	@1,w
                                 	cpc	@0,w
                                 	.endmacro
                                 .macro	TST2
                                 	clr	w
                                 	cp	@1,w
                                 	cpc	@0,w
                                 	.endmacro
                                 
                                 .macro	ADDI4			; add immediate
                                 	subi	@3,  low(-@4)
                                 	sbci	@2, high(-@4)
                                 	sbci	@1,byte3(-@4)
                                 	sbci	@0,byte4(-@4)
                                 	.endmacro
                                 .macro	ADDI3
                                 	subi	@2,  low(-@3)
                                 	sbci	@1, high(-@3)
                                 	sbci	@0,byte3(-@3)
                                 	.endmacro
                                 .macro	ADDI2
                                 	subi	@1,  low(-@2)
                                 	sbci	@0, high(-@2)
                                 	.endmacro
                                 	
                                 .macro	SUBI4			; subtract immediate
                                 	subi	@3,  low(@4)
                                 	sbci	@2, high(@4)
                                 	sbci	@1,byte3(@4)
                                 	sbci	@0,byte4(@4)
                                 	.endmacro
                                 .macro	SUBI3
                                 	subi	@2,  low(@3)
                                 	sbci	@1, high(@3)
                                 	sbci	@0,byte3(@3)
                                 	.endmacro
                                 .macro	SUBI2
                                 	subi	@1,  low(@2)
                                 	sbci	@0, high(@2)
                                 	.endmacro
                                 
                                 .macro	LSL5			; logical shift left
                                 	lsl	@4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	LSL4
                                 	lsl	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	LSL3
                                 	lsl	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	LSL2
                                 	lsl	@1
                                 	rol	@0
                                 	.endmacro
                                 	
                                 .macro	LSR4			; logical shift right
                                 	lsr	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	.endmacro
                                 .macro	LSR3
                                 	lsr	@0
                                 	ror	@1
                                 	ror	@2
                                 	.endmacro
                                 .macro	LSR2
                                 	lsr	@0
                                 	ror	@1
                                 	.endmacro
                                 
                                 .macro	ASR4			; arithmetic shift right
                                 	asr	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	.endmacro
                                 .macro	ASR3
                                 	asr	@0
                                 	ror	@1
                                 	ror	@2
                                 	.endmacro
                                 .macro	ASR2
                                 	asr	@0
                                 	ror	@1
                                 	.endmacro
                                 
                                 .macro	ROL8			; rotate left through carry
                                 	rol	@7
                                 	rol	@6
                                 	rol	@5
                                 	rol	@4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL7
                                 	rol	@6
                                 	rol	@5
                                 	rol	@4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL6
                                 	rol	@5
                                 	rol	@4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL5
                                 	rol	@4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL4
                                 	rol	@3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL3
                                 	rol	@2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 .macro	ROL2
                                 	rol	@1
                                 	rol	@0
                                 	.endmacro
                                 
                                 .macro	ROR8			; rotate right through carry
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	ror	@4
                                 	ror	@5
                                 	ror	@6
                                 	ror	@7
                                 	.endmacro
                                 .macro	ROR7
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	ror	@4
                                 	ror	@5
                                 	ror	@6
                                 	.endmacro
                                 .macro	ROR6
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	ror	@4
                                 	ror	@5
                                 	.endmacro
                                 .macro	ROR5
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	ror	@4
                                 	.endmacro	
                                 .macro	ROR4
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	ror	@3
                                 	.endmacro
                                 .macro	ROR3
                                 	ror	@0
                                 	ror	@1
                                 	ror	@2
                                 	.endmacro
                                 .macro	ROR2
                                 	ror	@0
                                 	ror	@1
                                 	.endmacro
                                 
                                 .macro	PUSH2
                                 	push	@0
                                 	push	@1
                                 	.endmacro	
                                 .macro	POP2
                                 	pop	@1
                                 	pop	@0
                                 	.endmacro
                                 
                                 .macro	PUSH3
                                 	push	@0
                                 	push	@1
                                 	push	@2
                                 	.endmacro	
                                 .macro	POP3
                                 	pop	@2
                                 	pop	@1
                                 	pop	@0
                                 	.endmacro
                                 	
                                 .macro	PUSH4
                                 	push	@0
                                 	push	@1
                                 	push	@2
                                 	push	@3
                                 	.endmacro	
                                 .macro	POP4
                                 	pop	@3
                                 	pop	@2
                                 	pop	@1
                                 	pop	@0
                                 	.endmacro	
                                 	
                                 .macro	PUSH5
                                 	push	@0
                                 	push	@1
                                 	push	@2
                                 	push	@3
                                 	push	@4
                                 	.endmacro	
                                 .macro	POP5
                                 	pop	@4
                                 	pop	@3
                                 	pop	@2
                                 	pop	@1
                                 	pop	@0
                                 	.endmacro	
                                 
                                 ; --- SRAM operations ---
                                 .macro	INCS4	; sram		; increment SRAM 4-byte variable
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	brne	end
                                 	lds	w,@0+1
                                 	inc	w
                                 	sts	@0+1,w
                                 	brne	end
                                 	lds	w,@0+2
                                 	inc	w
                                 	sts	@0+2,w
                                 	brne	end
                                 	lds	w,@0+3
                                 	inc	w
                                 	sts	@0+3,w
                                 end:	
                                 	.endmacro
                                 
                                 .macro	INCS3	; sram		; increment SRAM 3-byte variable
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	brne	end
                                 	lds	w,@0+1
                                 	inc	w
                                 	sts	@0+1,w
                                 	brne	end
                                 	lds	w,@0+2
                                 	inc	w
                                 	sts	@0+2,w
                                 end:	
                                 	.endmacro
                                 
                                 .macro	INCS2	; sram		; increment SRAM 2-byte variable
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	brne	end
                                 	lds	w,@0+1
                                 	inc	w
                                 	sts	@0+1,w
                                 end:	
                                 	.endmacro
                                 
                                 .macro	INCS	; sram		; increment SRAM 1-byte variable
                                 	lds	w,@0
                                 	inc	w
                                 	sts	@0,w
                                 	.endmacro
                                 
                                 .macro	DECS4	; sram		; decrement SRAM 4-byte variable
                                 	ldi	w,1
                                 	lds	u,@0
                                 	sub	u,w
                                 	sts	@0,u
                                 	clr	w
                                 	lds	u,@0+1
                                 	sbc	u,w
                                 	sts	@0+1,u
                                 	lds	u,@0+2
                                 	sbc	u,w
                                 	sts	@0+2,u
                                 	lds	u,@0+3
                                 	sbc	u,w
                                 	sts	@0+3,u
                                 	.endmacro
                                 .macro	DECS3	; sram		; decrement SRAM 3-byte variable
                                 	ldi	w,1
                                 	lds	u,@0
                                 	sub	u,w
                                 	sts	@0,u
                                 	clr	w
                                 	lds	u,@0+1
                                 	sbc	u,w
                                 	sts	@0+1,u
                                 	lds	u,@0+2
                                 	sbc	u,w
                                 	sts	@0+2,u
                                 	.endmacro
                                 .macro	DECS2	; sram		; decrement SRAM 2-byte variable
                                 	ldi	w,1
                                 	lds	u,@0
                                 	sub	u,w
                                 	sts	@0,u
                                 	clr	w
                                 	lds	u,@0+1
                                 	sbc	u,w
                                 	sts	@0+1,u
                                 	.endmacro
                                 .macro	DECS	; sram		; decrement
                                 	lds	w,@0
                                 	dec	w
                                 	sts	@0,w
                                 	.endmacro
                                 
                                 .macro	MOVS4	; addr0,addr1	; [addr0] <-- [addr1]
                                 	lds	w,@1
                                 	sts	@0,w
                                 	lds	w,@1+1
                                 	sts	@0+1,w
                                 	lds	w,@1+2
                                 	sts	@0+2,w
                                 	lds	w,@3+1
                                 	sts	@0+3,w	
                                 	.endmacro
                                 .macro	MOVS3	; addr0,addr1	; [addr0] <-- [addr1]
                                 	lds	w,@1
                                 	sts	@0,w
                                 	lds	w,@1+1
                                 	sts	@0+1,w
                                 	lds	w,@1+2
                                 	sts	@0+2,w
                                 	.endmacro
                                 .macro	MOVS2	; addr0,addr1	; [addr0] <-- [addr1]
                                 	lds	w,@1
                                 	sts	@0,w
                                 	lds	w,@1+1
                                 	sts	@0+1,w
                                 	.endmacro
                                 .macro	MOVS	; addr0,addr1	; [addr0] <-- [addr1]
                                 	lds	w,@1
                                 	sts	@0,w
                                 	.endmacro
                                 
                                 .macro	SEXT	; reg1,reg0	; sign extend
                                 	clr	@0
                                 	sbrc	@1,7
                                 	dec	@0
                                 	.endmacro
                                 
                                 ; =======================================
                                 ;	Jump/Call with constant arguments
                                 ; =======================================
                                 	
                                 ; --- calls with arguments a,b,XYZ ---
                                 .macro	CX	; subroutine,x
                                 	ldi	xl, low(@1)
                                 	ldi	xh,high(@1)
                                 	rcall	@0
                                 	.endmacro
                                 .macro	CXY	; subroutine,x,y
                                 	ldi	xl, low(@1)
                                 	ldi	xh,high(@1)
                                 	ldi	yl, low(@2)
                                 	ldi	yh,high(@2)	
                                 	rcall	@0
                                 	.endmacro		
                                 .macro	CXZ	; subroutine,x,z
                                 	ldi	xl, low(@1)
                                 	ldi	xh,high(@1)
                                 	ldi	zl, low(@2)
                                 	ldi	zh,high(@2)	
                                 	rcall	@0
                                 	.endmacro		
                                 .macro	CXYZ	; subroutine,x,y,z
                                 	ldi	xl, low(@1)
                                 	ldi	xh,high(@1)
                                 	ldi	yl, low(@2)
                                 	ldi	yh,high(@2)
                                 	ldi	zl, low(@3)
                                 	ldi	zh,high(@3)		
                                 	rcall	@0
                                 	.endmacro
                                 .macro	CW	; subroutine,w
                                 	ldi	w, @1
                                 	rcall	@0
                                 	.endmacro
                                 .macro	CA	; subroutine,a
                                 	ldi	a0, @1
                                 	rcall	@0
                                 	.endmacro
                                 .macro	CAB	; subroutine,a,b
                                 	ldi	a0, @1
                                 	ldi	b0, @2
                                 	rcall	@0
                                 	.endmacro
                                 
                                 ; --- jump with arguments w,a,b ---
                                 .macro	JW	; subroutine,w
                                 	ldi	w, @1
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	JA	; subroutine,a
                                 	ldi	a0, @1
                                 	rjmp	@0
                                 	.endmacro
                                 .macro	JAB	; subroutine,a,b
                                 	ldi	a0, @1
                                 	ldi	b0, @2
                                 	rjmp	@0
                                 	.endmacro
                                 .list
                                 .include "definitions.asm"   ; include register/constant definitions
                                 
                                 ; purpose library, definition of addresses and constants
                                 ; 20171114 A.S.
                                 
                                 ; === definitions  ===
                                 .list
                                 
                                 ; === definitions ===
                                 .equ    KPDD = DDRD
                                 .equ    KPDO = PORTD
                                 .equ    KPDI = PIND
                                 
                                 .equ    KPD_DELAY = 30   ; msec, debouncing keys of keypad
                                 
                                 .def    wr0 = r2        ; detected column in hex
                                 .def    wr1 = r1        ; detected row in hex
                                 .def    mask = r14      ; row mask indicating which row has been detected in bin
                                 .def    wr2 = r15       ; semaphore: must enter LCD display routine, unary: 0 or other
                                 
                                 ; === interrupt vector table ===
                                 .org 0x000
000000 940c 0400                     jmp reset
                                 .org 0x0002
000002 940c 000a                     jmp isr_row1    ; external interrupt INT0 = bit 0 du PORTD cable sur Row1
                                 .org 0x0004
000004 940c 0014                     jmp isr_row2    ; external interrupt INT1 = bit 1 du PORTD
                                 .org 0x0006
000006 940c 001e                     jmp isr_row3    ; external interrupt INT2 = bit 2 du PORTD
                                 .org 0x0008
000008 940c 0028                     jmp isr_row4    ; external interrupt INT3 = bit 3 du PORTD
                                 
                                 ; === interrupt service routines ===
                                 isr_row1:
00000a 9bc0
00000b c002
00000c 98c0
00000d c001
00000e 9ac0                          INVP    PORTB, 0          ; Toggle led 0 for visual feedback
00000f e000
000010 2e10                          _LDI    wr1, 0x00       
000011 e001
000012 2ee0                          _LDI    mask, 0b00000001  ; detected in row 1 on PIND0
000013 c01e                          rjmp    column_detect
                                 	
                                 
                                 isr_row2:
000014 9bc1
000015 c002
000016 98c1
000017 c001
000018 9ac1                          INVP    PORTB, 1		  ; Toggle led 1 for visual feedback
000019 e001
00001a 2e10                          _LDI    wr1, 0x01
00001b e002
00001c 2ee0                          _LDI    mask, 0b00000010 ; detected in row 2 on PIND1
00001d c014                          rjmp    column_detect
                                 	
                                 
                                 isr_row3:
00001e 9bc2
00001f c002
000020 98c2
000021 c001
000022 9ac2                          INVP    PORTB, 2          ; Toggle led 2 for visual feedback
000023 e002
000024 2e10                          _LDI    wr1, 0x02
000025 e004
000026 2ee0                          _LDI    mask, 0b00000100  ; detected in row 3 on PIND2
000027 c00a                          rjmp    column_detect
                                 	
                                 
                                 isr_row4:
000028 9bc3
000029 c002
00002a 98c3
00002b c001
00002c 9ac3                          INVP    PORTB, 3          ; Toggle led 3 for visual feedback
00002d e003
00002e 2e10                          _LDI    wr1, 0x03
00002f e008
000030 2ee0                          _LDI    mask, 0b00001000  ; detected in row 4 on PIND3
000031 c000                          rjmp    column_detect
                                 	
                                 
                                 
                                 ; === Column Detection Routines ===
                                 ; Detecting the column: each column is pulled up then, one at a time, each column 
                                 ; is pulled low and if that forces the previously found row to also be pulled low
                                 ; then we have the right column
                                 
                                 column_detect:
000032 ef0f
000033 bb02                      	OUTI KPDO, 0xff
                                 col1:
000034 e10e
000035 2e30
000036 e001
000037 930f
000038 923f
000039 e300
00003a 2e30
00003b e006
00003c 943a
00003d f7f1
00003e 943a
00003f 950a
000040 f7d9
000041 903f
000042 910f
000043 943a
000044 f791
000045 950a
000046 f781                      	WAIT_MS	KPD_DELAY
000047 e70f
000048 bb02                      	OUTI	KPDO,0x7F	
000049 e10e
00004a 2e30
00004b e001
00004c 930f
00004d 923f
00004e e300
00004f 2e30
000050 e006
000051 943a
000052 f7f1
000053 943a
000054 950a
000055 f7d9
000056 903f
000057 910f
000058 943a
000059 f791
00005a 950a
00005b f781                      	WAIT_MS	KPD_DELAY
00005c b300                      	in		w,KPDI
00005d 210e                      	and		w,mask
00005e 2300                      	tst		w			
00005f f451                      	brne	col2 ; check next col since this didn't pull the line low
000060 e003
000061 2e20                      	_LDI	wr0,0x03
000062 9bc4
000063 c002
000064 98c4
000065 c001
000066 9ac4                      	INVP	PORTB,4		;;debug
000067 ef0f
000068 2ef0                      	_LDI wr2, 0xff
000069 c09d                      	rjmp isr_return
                                 col2:
00006a e10e
00006b 2e30
00006c e001
00006d 930f
00006e 923f
00006f e300
000070 2e30
000071 e006
000072 943a
000073 f7f1
000074 943a
000075 950a
000076 f7d9
000077 903f
000078 910f
000079 943a
00007a f791
00007b 950a
00007c f781                      	WAIT_MS	KPD_DELAY
00007d eb0f
00007e bb02                      	OUTI	KPDO,0xBF	
00007f e10e
000080 2e30
000081 e001
000082 930f
000083 923f
000084 e300
000085 2e30
000086 e006
000087 943a
000088 f7f1
000089 943a
00008a 950a
00008b f7d9
00008c 903f
00008d 910f
00008e 943a
00008f f791
000090 950a
000091 f781                      	WAIT_MS	KPD_DELAY
000092 b300                      	in		w,KPDI
000093 210e                      	and		w,mask
000094 2300                      	tst		w			
000095 f451                      	brne	col3
000096 e002
000097 2e20                      	_LDI	wr0,0x02
000098 9bc5
000099 c002
00009a 98c5
00009b c001
00009c 9ac5                      	INVP	PORTB,5		;;debug
00009d ef0f
00009e 2ef0                      	_LDI wr2, 0xff
00009f c067                      	rjmp isr_return
                                 col3:
0000a0 e10e
0000a1 2e30
0000a2 e001
0000a3 930f
0000a4 923f
0000a5 e300
0000a6 2e30
0000a7 e006
0000a8 943a
0000a9 f7f1
0000aa 943a
0000ab 950a
0000ac f7d9
0000ad 903f
0000ae 910f
0000af 943a
0000b0 f791
0000b1 950a
0000b2 f781                      	WAIT_MS	KPD_DELAY
0000b3 ed0f
0000b4 bb02                      	OUTI	KPDO,0xDF	
0000b5 e10e
0000b6 2e30
0000b7 e001
0000b8 930f
0000b9 923f
0000ba e300
0000bb 2e30
0000bc e006
0000bd 943a
0000be f7f1
0000bf 943a
0000c0 950a
0000c1 f7d9
0000c2 903f
0000c3 910f
0000c4 943a
0000c5 f791
0000c6 950a
0000c7 f781                      	WAIT_MS	KPD_DELAY
0000c8 b300                      	in		w,KPDI
0000c9 210e                      	and		w,mask
0000ca 2300                      	tst		w			
0000cb f451                      	brne	col4
0000cc e001
0000cd 2e20                      	_LDI	wr0,0x01
0000ce 9bc6
0000cf c002
0000d0 98c6
0000d1 c001
0000d2 9ac6                      	INVP	PORTB,6		;;debug
0000d3 ef0f
0000d4 2ef0                      	_LDI wr2, 0xff
0000d5 c031                      	rjmp isr_return
                                 col4:
0000d6 e10e
0000d7 2e30
0000d8 e001
0000d9 930f
0000da 923f
0000db e300
0000dc 2e30
0000dd e006
0000de 943a
0000df f7f1
0000e0 943a
0000e1 950a
0000e2 f7d9
0000e3 903f
0000e4 910f
0000e5 943a
0000e6 f791
0000e7 950a
0000e8 f781                      	WAIT_MS	KPD_DELAY
0000e9 ee0f
0000ea bb02                      	OUTI	KPDO,0xEF	
0000eb e10e
0000ec 2e30
0000ed e001
0000ee 930f
0000ef 923f
0000f0 e300
0000f1 2e30
0000f2 e006
0000f3 943a
0000f4 f7f1
0000f5 943a
0000f6 950a
0000f7 f7d9
0000f8 903f
0000f9 910f
0000fa 943a
0000fb f791
0000fc 950a
0000fd f781                      	WAIT_MS	KPD_DELAY
0000fe b300                      	in		w,KPDI
0000ff 210e                      	and		w,mask
000100 2300                      	tst		w			
000101 f429                      	brne	isr_return
000102 e000
000103 2e20                      	_LDI	wr0,0x00
                                 	;INVP	PORTB,3		;;debug
000104 ef0f
000105 2ef0                      	_LDI wr2, 0xff
000106 c000                      	rjmp isr_return
                                 
                                 
                                 isr_return:
                                 	;reinitialize detection
000107 e00f
000108 bb02                          OUTI    KPDO,0x0f         ; drive bits 4-7 low = columns a 0V
000109 9518                      	reti
                                 
                                 .include "lcd.asm"
                                 
                                 ; purpose  LCD HD44780U library
                                 ; ATmega 128 and Atmel Studio 7.0 compliant
                                 
                                 ; === definitions ===
                                 .equ	LCD_IR	= 0x8000	; address LCD instruction reg
                                 .equ	LCD_DR	= 0xc000	; address LCD data register
                                 
                                 ; === subroutines ===
                                 LCD_wr_ir:
                                 ; in	w (byte to write to LCD IR)
00010a 9030 8000                 	lds	u, LCD_IR		; read IR to check busy flag  (bit7)
00010c fc37
00010d cffc                      	JB1	u,7,LCD_wr_ir	; Jump if Bit=1 (still busy)
00010e d003                      	rcall	lcd_4us		; delay to increment DRAM addr counter
00010f 9300 8000                 	sts	LCD_IR, w		; store w in IR
000111 9508                      	ret
                                 	
                                 lcd_4us:
000112 d000                      	rcall	lcd_2us		; recursive call		
                                 lcd_2us:
000113 0000                      	nop					; rcall(3) + nop(1) + ret(4) = 8 cycles (2us)
000114 9508                      	ret
                                 
                                 LCD:
                                 LCD_putc:
000115 302d
000116 f169                      	JK	a0,CR,LCD_cr	; Jump if a0=CR
000117 302a
000118 f1a9                      	JK	a0,LF,LCD_lf	; Jump if a0=LF
                                 LCD_wr_dr:
                                 ; in	a0 (byte to write to LCD DR)
000119 9100 8000                 	lds	w, LCD_IR		; read IR to check busy flag  (bit7)
00011b fd07
00011c cffc                      	JB1	w,7,LCD_wr_dr	; Jump if Bit=1 (still busy)
00011d dff4                      	rcall	lcd_4us		; delay to increment DRAM addr counter
00011e 9320 c000                 	sts	LCD_DR, a0		; store a0 in DR
000120 9508                      	ret	
                                 	
000121 e001
000122 cfe7                      LCD_clear:		JW	LCD_wr_ir, 0b00000001		; clear display
000123 e002
000124 cfe5                      LCD_home:		JW	LCD_wr_ir, 0b00000010		; return home
000125 e100
000126 cfe3                      LCD_cursor_left:	JW	LCD_wr_ir, 0b00010000	; move cursor to left
000127 e104
000128 cfe1                      LCD_cursor_right:	JW	LCD_wr_ir, 0b00010100	; move cursor to right
000129 e108
00012a cfdf                      LCD_display_left:	JW	LCD_wr_ir, 0b00011000	; shifts display to left
00012b e10c
00012c cfdd                      LCD_display_right:	JW	LCD_wr_ir, 0b00011100	; shifts display to right
00012d e00d
00012e cfdb                      LCD_blink_on:		JW	LCD_wr_ir, 0b00001101	; Display=1,Cursor=0,Blink=1
00012f e00c
000130 cfd9                      LCD_blink_off:		JW	LCD_wr_ir, 0b00001100	; Display=1,Cursor=0,Blink=0
000131 e00e
000132 cfd7                      LCD_cursor_on:		JW	LCD_wr_ir, 0b00001110	; Display=1,Cursor=1,Blink=0
000133 e00c
000134 cfd5                      LCD_cursor_off:		JW	LCD_wr_ir, 0b00001100	; Display=1,Cursor=0,Blink=0
                                 		
                                 LCD_init:
000135 b705                      	in	w,MCUCR					; enable access to ext. SRAM
000136 6c00                      	sbr	w,(1<<SRE)+(1<<SRW10)
000137 bf05                      	out	MCUCR,w
000138 e001
000139 dfd0                      	CW	LCD_wr_ir, 0b00000001	; clear display
00013a e006
00013b dfce                      	CW	LCD_wr_ir, 0b00000110	; entry mode set (Inc=1, Shift=0)
00013c e00c
00013d dfcc                      	CW	LCD_wr_ir, 0b00001100	; Display=1,Cursor=0,Blink=0	
00013e e308
00013f dfca                      	CW	LCD_wr_ir, 0b00111000	; 8bits=1, 2lines=1, 5x8dots=0
000140 9508                      	ret
                                 
                                 LCD_pos:
                                 ; in	a0 = position (0x00..0x0f first line, 0x40..0x4f second line)
000141 2f02                      	mov	w,a0
000142 6800                      	ori	w,0b10000000
000143 cfc6                      	rjmp	LCD_wr_ir
                                 
                                 LCD_cr:
                                 ; moving the cursor to the beginning of the line (carriage return)
000144 9100 8000                 	lds	w, LCD_IR			; read IR to check busy flag  (bit7)
000146 fd07
000147 cffc                      	JB1	w,7,LCD_cr			; Jump if Bit=1 (still busy)
000148 7400                      	andi	w,0b01000000	; keep bit6 (begin of line 1/2)
000149 6800                      	ori	w,0b10000000		; write address command
00014a dfc7                      	rcall	lcd_4us			; delay to increment DRAM addr counter
00014b 9300 8000                 	sts	LCD_IR,w			; store in IR
00014d 9508                      	ret
                                 
                                 LCD_lf:
                                 ; moving the cursor to the beginning of the line 2 (line feed)
00014e 932f                      	push	a0				; safeguard a0
00014f e420                      	ldi	a0,$40				; load position $40 (begin of line 2)
000150 dff0                      	rcall	LCD_pos			; set cursor position
000151 912f                      	pop	a0					; restore a0
                                 .include "printf.asm"
000152 9508                      
                                 ; purpose library, formatted output generation
                                 ; author (c) R.Holzer (adapted MICRO210/EE208 A.Schmid)
                                 ; v2019.02 20180821 AxS supports SRAM input from 0x0260
                                 ;					through 0x02ff that should be reserved
                                 
                                 ; === description ===
                                 ; 
                                 ; The program "printf" interprets and prints formatted strings.
                                 ; The special formatting characters regognized are:
                                 ;
                                 ; FDEC	decimal number
                                 ; FHEX	hexadecimal number
                                 ; FBIN	binary number
                                 ; FFRAC	fixed fraction number
                                 ; FCHAR	single ASCII character
                                 ; FSTR	zero-terminated ASCII string
                                 ;	
                                 ; The special formatting characters are distinguished from normal 
                                 ; ASCII characters by having their bit7 set to 1.
                                 ;
                                 ; Signification of bit fields:
                                 ;
                                 ; b 	bytes		1..4 b bytes		2
                                 ; s 	sign		0(unsigned), 1(signed)	1
                                 ; i		integer digits	
                                 ; e 	base		2,,36			5
                                 ; dp 	dec. point	0..32			5
                                 ; $if	i=integer digits,  0=all digits,  1..15 digits 
                                 ;		f=fraction digits, 0=no fraction, 1..15 digits
                                 ;
                                 ; Formatting characters must be followed by an SRAM address (0..ff)
                                 ; that determines the origin of variables that must be printed (if any)
                                 ; FBIN,	sram
                                 ; FHEX,	sram
                                 ; FDEC,	sram
                                 ; FCHAR,sram
                                 ; FSTR,	sram
                                 ;
                                 ; The address 'sram' is a 1-byte constant. It addresses
                                 ; 	 0..1f	registers r0..r31, 
                                 ; 	20..3f	i/o ports, (need to be addressed with an offset of $20)
                                 ;	0x0260..0x02ff	SRAM
                                 ; Variables can be located into register and I/0s, and can also
                                 ; be stored into data SRAM at locations 0x0200 through 0x02ff. Any
                                 ; sram address higher than 0x0060 is assumed to be at (0x0260+address)
                                 ; from automatic address detection in _printf_formatted: and subsequent
                                 ; assignment to xh; xl keeps its value. Consequently, variables that are
                                 ; to be stored into SRAM and further printed by fprint must reside at
                                 ; 0x0200 up to 0x02ff, and must be addressed using a label. Usage: see
                                 ; file string1.asm, for example.
                                 
                                 ; The FFRAC formatting character must be followed by 
                                 ;	ONE sram address and 
                                 ;	TWO more formatting characters
                                 ; FFRAC,sram,dp,$if
                                 
                                 ; dp	decimal point position, 0=right, 32=left
                                 ; $if	format i.f, i=integer digits, f=fraction digits
                                 
                                 ; The special formatting characters use the following coding
                                 ;
                                 ; FDEC	11bb'iiis	i=0 all digits, i=1-7 digits
                                 ; FBIN	101i'iiis	i=0 8 digits,	i=1-7 digits
                                 ; FHEX	1001'iiis	i=0 8 digits,	i=1-7 digits
                                 ; FFRAC	1000'1bbs
                                 ; FCHAR	1000'0100
                                 ; FSTR	1000'0101
                                 ; FREP	1000'0110
                                 ; FFUNC	1000'0111
                                 ;	1000'0010
                                 ;	1000'0011
                                 ; FESC	1000'0000
                                 
                                 ; examples
                                 ; formatting string			printing
                                 ; "a=",FDEC,a,0				1-byte variable a, unsigned decimal
                                 ; "a=",FDEC2,a,0			2-byte variable a (a1,a0), unsigend
                                 ; "a=",FDEC|FSIGN,a,0		1-byte variable 1, signed decimal
                                 ; "n=",FBIN,PIND+$20,0		i/o port, binary, notice offset of $20
                                 ; "f=",FFRAC4|FSIGN,a,16,$88,0	4-byte signed fixed-point fraction
                                 ;				dec.point at 16, 8 int.digits, 8 frac.digits	
                                 ; "f=",FFRAC2,a,16,$18,0		2-byte unsigned fixed-point fraction
                                 ;				dec.point at 16, 1 int.digits, 8 frac.digits	
                                 ; "a=",FDEC|FDIG5|FSIGN,a,0	1-byte variable, 5-digit, decimal, signed
                                 ; "a=",FDEC|FDIG5,a,0		1-byte variable, 5-digit, decimal, unsigned
                                 
                                 ; === registers modified ===
                                 ; e0,e1	used to transmit address of putc routine
                                 ; zh,zl	used as pointer to prog-memory
                                 
                                 ; === constants ==============================================
                                 
                                 .equ	FDEC	= 0b11000000	; 1-byte variable
                                 .equ	FDEC2	= 0b11010000	; 2-byte variable
                                 .equ	FDEC3	= 0b11100000	; 3-byte variable
                                 .equ	FDEC4	= 0b11110000	; 4-byte variable
                                 
                                 .equ	FBIN	= 0b10100000
                                 .equ	FHEX	= 0b10010100	; 1-byte variable
                                 .equ	FHEX2	= 0b10011000	; 2-byte variable
                                 .equ	FHEX3	= 0b10011100	; 3-byte variable
                                 .equ	FHEX4	= 0b10010000	; 4-byte variable
                                 
                                 .equ	FFRAC	= 0b10001000	; 1-byte variable
                                 .equ	FFRAC2	= 0b10001010	; 2-byte variable
                                 .equ	FFRAC3	= 0b10001100	; 3-byte variable
                                 .equ	FFRAC4	= 0b10001110	; 4-byte variable
                                 
                                 .equ	FCHAR	= 0b10000100
                                 .equ	FSTR	= 0b10000101
                                 
                                 .equ	FSIGN	= 0b00000001
                                 
                                 .equ	FDIG1	= 1<<1
                                 .equ	FDIG2	= 2<<1
                                 .equ	FDIG3	= 3<<1	
                                 .equ	FDIG4	= 4<<1
                                 .equ	FDIG5	= 5<<1
                                 .equ	FDIG6	= 6<<1
                                 .equ	FDIG7	= 7<<1
                                 
                                 ; ===macro ====================================================
                                 
                                 .macro	PRINTF			; putc function (UART, LCD...)
                                 	ldi	w, low(@0)		; address of "putc" in e1:d0
                                 	mov	e0,w
                                 	ldi	w,high(@0)
                                 	mov	e1,w
                                 	rcall	_printf
                                 	.endmacro
                                 
                                 ; mod	y,z
                                 
                                 
                                 ; === routines ================================================
                                 
                                 _printf:
000153 91ff
000154 91ef                      	POPZ			; z points to begin of "string"
000155 0fee
000156 1fff                      	MUL2Z			; multiply Z by two, (word ptr -> byte ptr)
000157 93af
000158 93bf                      	PUSHX
                                 		
                                 _printf_read:
000159 95c8                      	lpm				; places prog_mem(Z) into r0 (=c)
00015a 9631                      	adiw	zl,1	; increment pointer Z
00015b 2000                      	tst	r0			; test for ZERO (=end of string)
00015c f021                      	breq	_printf_end	; char=0 indicates end of ascii string
00015d f04a                      	brmi	_printf_formatted ; bit7=1 indicates formatting character
00015e 2d00                      	mov	w,r0
00015f d017                      	rcall	_putw	; display the character
000160 cff8                      	rjmp	_printf_read	; read next character in the string
                                 	
                                 _printf_end:
000161 9631                      	adiw	zl,1	; point to the next character
000162 95f6
000163 95e7                      	DIV2Z			; divide by 2 (byte ptr -> word ptr)
000164 91bf
000165 91af                      	POPX
000166 9409                      	ijmp			; return to instruction after "string"
                                 
                                 _printf_formatted:
                                 
                                 ; FDEC	11bb'iiis
                                 ; FBIN	101i'iiis
                                 ; FHEX	1001'iiis
                                 ; FFRAC	1000'1bbs
                                 ; FCHAR	1000'0100
                                 ; FSTR	1000'0101
                                 
000167 fa00                      	bst	r0,0		; store sign in T
000168 2d00                      	mov	w,r0		; store formatting character in w
000169 95c8                      	lpm	
00016a 2da0                      	mov	xl,r0		; load x-pointer with SRAM address
00016b 36a0                      	cpi	xl,0x60
00016c f010                      	brlo rio_space
                                 dataram_space:		; variable originates from SRAM memory
00016d e0b2                      	ldi	xh,0x02		;>addresses are limited to 0x0260 through 0x02ff
00016e c001                      	rjmp space_detect_end	;>that enables automatic detection of the origin
                                 rio_space:			; variable originates from reg or I/O space 
00016f 27bb                      	clr	xh			; clear high-byte, addresses are 0x0000 through 0x003f (0x005f)
                                 space_detect_end:
000170 9631                       	adiw	zl,1	; increment pointer Z
                                 
                                 ;	JB1	w,6,_putdec
                                 ;	JB1	w,5,_putbin
                                 ;	JB1	w,4,_puthex
                                 ;	JB1	w,3,_putfrac
000171 3804
000172 f079                      	JK	w,FCHAR,_putchar
000173 3805
000174 f081                      	JK	w,FSTR ,_putstr
000175 c015                      	rjmp	_putnum
                                 	
000176 cfe2                      	rjmp	_printf_read	
                                 
                                 ; === putc (put character) ===============================
                                 ; in	w	character to put
                                 ;	e1,e0	address of output routine (UART, LCD putc)
                                 _putw:
000177 932f
000178 93ff
000179 93ef                      	PUSH3	a0,zh,zl
00017a 2de4
00017b 2df5
00017c 2f20                      	MOV3	a0,zh,zl, w,e1,e0
00017d 9509                      	icall			; indirect call to "putc"
00017e 91ef
00017f 91ff
000180 912f                      	POP3	a0,zh,zl
000181 9508                      	ret
                                 
                                 ; === putchar (put character) ============================
                                 ; in	x	pointer to character to put
                                 _putchar:
000182 910c                      	ld	w,x
000183 dff3                      	rcall	_putw
000184 cfd4                      	rjmp	_printf_read
                                 	
                                 ; === putstr (put string) ================================
                                 ; in	x	pointer to ascii string
                                 ;	b3,b2	address of output routine (UART, LCD putc)
                                 _putstr:
000185 910d                      	ld	w,x+
000186 2300                      	tst	w
000187 f409                      	brne	PC+2
000188 cfd0                      	rjmp	_printf_read
000189 dfed                      	rcall	_putw
00018a cffa                      	rjmp	_putstr
                                 
                                 ; === putnum (dec/bin/hex/frac) ===========================
                                 ; in	x	pointer to SRAM variable to print
                                 ; 	r0	formatting character
                                 	
                                 _putnum:
00018b 935f
00018c 934f
00018d 933f
00018e 932f                      	PUSH4	a3,a2,a1,a0	; safeguard a
00018f 939f
000190 938f
000191 937f
000192 936f                      	PUSH4	b3,b2,b1,b0	; safeguard b	
000193 912d
000194 913d
000195 914d
000196 915d                      	LDX4	a3,a2,a1,a0	; load operand to print into a
                                 
                                 ; FDEC	11bb'iiis
                                 ; FBIN	101i'iiis
                                 ; FHEX	1001'iiis
                                 ; FRACT	1000'1bbs
                                 
000197 fd06
000198 c006                      	JB1	w,6,_putdec
000199 fd05
00019a c00f                      	JB1	w,5,_putbin
00019b fd04
00019c c010                      	JB1	w,4,_puthex
00019d fd03
00019e c019                      	JB1	w,3,_putfrac
                                 
                                 ; FDEC	11bb'iiis
                                 _putdec:
00019f e06a                      	ldi	b0,10		; b0 = base (10)
                                 
0001a0 2f70                      	mov	b1,w
0001a1 9576                      	lsr	b1
0001a2 7077                      	andi	b1,0b111	
0001a3 9572                      	swap	b1		; b1 = format 0iii'0000 (integer digits)
0001a4 e080                      	ldi	b2,0		; b2 = dec. point position = 0 (right)
                                 	
0001a5 2f90                      	mov	b3,w
0001a6 9592                      	swap	b3
0001a7 7093                      	andi	b3,0b11
0001a8 9593                      	inc	b3			; b3 = number of bytes (1..4)
0001a9 c01a                      	rjmp	_getnum	; get number of digits (iii)
                                 
                                 ; FBIN	101i'iiis	addr
                                 _putbin:	
0001aa e062                      	ldi	b0,2		; b0 = base (2)
0001ab e094                      	ldi	b3,4		; b3 = number of bytes (4)	
0001ac c003                      	rjmp	_getdig	; get number of digits (iii)
                                 
                                 ; FHEX	1001'iiis	addr
                                 _puthex:	
0001ad e160                      	ldi	b0,16		; b0 = base (16)
0001ae e094                      	ldi	b3,4		; b3 = number of bytes (4)
0001af c000                      	rjmp	_getdig
                                 
                                 _getdig:
0001b0 2f70                      	mov	b1,w
0001b1 9576                      	lsr	b1
0001b2 7077                      	andi	b1,0b111
0001b3 f409                      	brne	PC+2
0001b4 e078                      	ldi	b1,8		; if b1=0 then 8-digits
0001b5 9572                      	swap	b1		; b1 = format 0iii'0000 (integer digits)
0001b6 e080                      	ldi	b2, 0		; b2 = dec. point position = 0 (right)
0001b7 c00c                      	rjmp	_getnum
                                 
                                 ; FFRAC	1000'1bbs	addr	 00dd'dddd, 	iiii'ffff
                                 	
                                 _putfrac:
0001b8 e06a                      	ldi	b0,10		; base=10	
0001b9 95c8                      	lpm
0001ba 2d80                      	mov	b2,r0		; load dec.point position
0001bb 9631                      	adiw	zl,1	; increment char pointer
0001bc 95c8                      	lpm
0001bd 2d70                      	mov	b1,r0		; load ii.ff format
0001be 9631                      	adiw	zl,1	; increment char pointer
                                 	
0001bf 2f90                      	mov	b3,w
0001c0 9595                      	asr	b3
0001c1 7093                      	andi	b3,0b11
0001c2 9593                      	inc	b3			; b3 = number of bytes (1..4)
                                 
0001c3 c000                      	rjmp	_getnum
                                 
                                 _getnum:
                                 ; in 	a	4-byte variable
                                 ; 	b3	number of bytes (1..4)
                                 ;	T	sign, 0=unsigned, 1=signed
                                 
0001c4 3094
0001c5 f081                      	JK	b3,4,_printf_4b
0001c6 3093
0001c7 f051                      	JK	b3,3,_printf_3b
0001c8 3092
0001c9 f021                      	JK	b3,2,_printf_2b	
                                 	
                                 _printf_1b:			; sign extension
0001ca 2733                      	clr	a1
0001cb f416                      	brtc	PC+3	; T=1 sign extension
0001cc fd27                      	sbrc	a0,7
0001cd ef3f                      	ldi	a1,0xff
                                 _printf_2b:
0001ce 2744                      	clr	a2
0001cf f416                      	brtc	PC+3	; T=1 sign extension	
0001d0 fd37                      	sbrc	a1,7
0001d1 ef4f                      	ldi	a2,0xff
                                 _printf_3b:	
0001d2 2755                      	clr	a3
0001d3 f416                      	brtc	PC+3	; T=1 sign extension
0001d4 fd47                      	sbrc	a2,7
0001d5 ef5f                      	ldi	a3,0xff
                                 _printf_4b:
                                 
0001d6 d009                      	rcall	_ftoa		; float to ascii
0001d7 916f
0001d8 917f
0001d9 918f
0001da 919f                      	POP4	b3,b2,b1,b0	; restore b
0001db 912f
0001dc 913f
0001dd 914f
0001de 915f                      	POP4	a3,a2,a1,a0	; restore a
                                 	
0001df cf79                      	rjmp	_printf_read
                                 
                                 ; ===============================================
                                 ; func	ftoa
                                 ; converts a fixed-point fractional number to an ascii string
                                 ; author (c) Raphael Holzer
                                 ;
                                 ; in	a3-a0	variable to print
                                 ;	b0	base, 2 to 36, but usually decimal (10)
                                 ;	b1	number of digits to print ii.ff
                                 ; 	b2	position of the decimal point (0=right, 32=left)
                                 ;	T	sign (T=0 unsiged, T=1 signed)
                                 
                                 _ftoa:
0001e0 92cf                      	push	d0
0001e1 92bf
0001e2 92af
0001e3 929f
0001e4 928f                      	PUSH4	c3,c2,c1,c0	; c = fraction part, a = integer part
0001e5 18bb
0001e6 24aa
0001e7 2499
0001e8 2488                      	CLR4	c3,c2,c1,c0	; clear fraction part
                                 
0001e9 f486                      	brtc	_ftoa_plus	; if T=0 then unsigned
0001ea 94e8                      	clt
0001eb 2355                      	tst	a3				; if MSb(a)=1 then a=-a
0001ec f46a                      	brpl	_ftoa_plus
0001ed 9468                      	set					; T=1 (minus)
0001ee 2377                      	tst	b1
0001ef f009                      	breq	PC+2		; if b1=0 the print ALL digits
0001f0 5170                      	subi	b1,0x10		; decrease int digits
0001f1 9550
0001f2 9540
0001f3 9530
0001f4 9520
0001f5 ef0f
0001f6 1b20
0001f7 0b30
0001f8 0b40
0001f9 0b50                      	NEG4	a3,a2,a1,a0	; negate a
                                 _ftoa_plus:	
0001fa 2388                      	tst	b2				; b0=0 (only integer part)
0001fb f051                      	breq	_ftoa_int	
                                 _ftoa_shift:	
0001fc 9555
0001fd 9547
0001fe 9537
0001ff 9527                      	ASR4	a3,a2,a1,a0	; a = integer part	
000200 94b7
000201 94a7
000202 9497
000203 9487                      	ROR4	c3,c2,c1,c0	; c = fraction part
000204 958a
000205 f7b1                      	DJNZ	b2,_ftoa_shift
                                 _ftoa_int:
000206 937f                      	push	b1			; ii.ff (ii=int digits)
000207 9572                      	swap	b1
000208 707f                      	andi	b1,0x0f
                                 	
000209 e20e                      	ldi	w,'.'			; push decimal point
00020a 930f                      	push	w
                                 _ftoa_int1:
00020b d045                      	rcall	_div41		; int=int/10
00020c 2d0c                      	mov	w,d0			; d=reminder
00020d d030                      	rcall	_hex2asc
00020e 930f                      	push	w			; push rem(int/10)
00020f 2700
000210 1720
000211 0730
000212 0740
000213 0750                      	TST4	a3,a2,a1,a0	; (int/10)=?
000214 f029                      	breq	_ftoa_space	; (int/10)=0 then finished
000215 2377                      	tst	b1
000216 f3a1                      	breq	_ftoa_int1	; if b1=0 then print ALL int-digits
000217 957a
000218 f791                      	DJNZ	b1,_ftoa_int1
000219 c007                      	rjmp	_ftoa_sign
                                 _ftoa_space:
00021a 2377                      	tst	b1				; if b1=0 then print ALL int-digits
00021b f029                      	breq	_ftoa_sign
00021c 957a                      	dec	b1
00021d f019                      	breq	_ftoa_sign
00021e e200                      	ldi	w,' '			; write spaces
00021f df57                      	rcall	_putw	
000220 cff9                      	rjmp	_ftoa_space
                                 _ftoa_sign:
000221 f416                      	brtc	PC+3		; if T=1 then write 'minus'
000222 e20d                      	ldi	w,'-'
000223 df53                      	rcall	_putw
                                 _ftoa_int3:
000224 910f                      	pop	w
000225 320e                      	cpi	w,'.'
000226 f011                      	breq	PC+3
000227 df4f                      	rcall	_putw
000228 cffb                      	rjmp	_ftoa_int3
                                 
000229 917f                      	pop	b1				; ii.ff (ff=frac digits)
00022a 707f                      	andi	b1,0x0f
00022b 2377                      	tst	b1
00022c f059                      	breq	_ftoa_end
                                 _ftoa_point:	
00022d df49                      	rcall	_putw		; write decimal point
00022e 2d28
00022f 2d39
000230 2d4a
000231 2d5b                      	MOV4	a3,a2,a1,a0, c3,c2,c1,c0		
                                 _ftoa_frac:
000232 d011                      	rcall	_mul41		; d.frac=10*frac
000233 2d0c                      	mov	w,d0
000234 d009                      	rcall	_hex2asc
000235 df41                      	rcall	_putw
000236 957a
000237 f7d1                      	DJNZ	b1,_ftoa_frac
                                 _ftoa_end:
000238 908f
000239 909f
00023a 90af
00023b 90bf                      	POP4	c3,c2,c1,c0
00023c 90cf                      	pop	d0
00023d 9508                      	ret
                                 
                                 ; === hexadecimal to ascii ===
                                 ; in	w
                                 _hex2asc:
00023e 300a                      	cpi	w,10
00023f f410                      	brsh	PC+3
000240 5d00                      	addi	w,'0'
000241 9508                      	ret
000242 5a09                      	addi	w,('a'-10)
000243 9508                      	ret
                                 
                                 ; === multiply 4byte*1byte ===
                                 ; funct mul41
                                 ; multiplies a3-a0 (4-byte) by b0 (1-byte)
                                 ; author (c) Raphael Holzer, EPFL
                                 ; 
                                 ; in	a3..a0	multiplicand (argument to multiply)
                                 ;	b0	multiplier
                                 ; out	a3..a0	result
                                 ; 	d0	result MSB (byte 4)
                                 ;
000244 24cc                      _mul41:	clr	d0			; clear byte4 of result
000245 e200                      	ldi	w,32			; load bit counter
000246 9488                      __m41:	clc				; clear carry
000247 fd20                      	sbrc	a0,0		; skip addition if LSB=0
000248 0ec6                      	add	d0,b0			; add b to MSB of a
000249 94c7
00024a 9557
00024b 9547
00024c 9537
00024d 9527                      	ROR5	d0,a3,a2,a1,a0	; shift-right c, LSB (of b) into carry
00024e 950a
00024f f7b1                      	DJNZ	w,__m41		; Decrement and Jump if bit-count Not Zero
000250 9508                      	ret
                                 
                                 ; === divide 4byte/1byte ===
                                 ; func div41
                                 ; in	a0..a3 	divident (argument to divide)
                                 ;	b0 	divider
                                 ; out	a0..a3 	result 
                                 ;	d0	reminder
                                 ;
000251 24cc                      _div41:	clr	d0			; d will contain the remainder
000252 e200                      	ldi	w,32			; load bit counter
000253 1f22
000254 1f33
000255 1f44
000256 1f55
000257 1ccc                      __d41:	ROL5	d0,a3,a2,a1,a0	; shift carry into result c
000258 1ac6                      	sub	d0, b0			; subtract b from remainder
000259 f408                      	brcc	PC+2	
00025a 0ec6                      	add	d0, b0			; restore if remainder became negative
00025b 950a
00025c f7b1                      	DJNZ	w,__d41		; Decrement and Jump if bit-count Not Zero
00025d 1f22
00025e 1f33
00025f 1f44
000260 1f55                      	ROL4	a3,a2,a1,a0	; last shift (carry into result c)
000261 9550
000262 9540
000263 9530
000264 9520                      	COM4	a3,a2,a1,a0	; complement result
000265 9508                      	ret
                                 
                                 ; FDEC	decimal number
                                 ; FHEX	hexadecimal number
                                 ; FBIN	binary number
                                 ; FFRAC	fixed fraction number
                                 ; FCHAR	single ASCII character
                                 ; FSTR	zero-terminated ASCII string
                                 
                                 ;TODO: Store code as a string in SRAM and change print_code to print the current code
                                 
                                 
                                 
                                 ; Initialization and configuration
                                 .org 0x400
                                 
                                 reset:  ;in : None, out: KPDD, KPDO, DDRB, EIMSK, EICRB, PORTB, mod: mask, w, _w, wr0, wr1, wr2, a0, b0, b3, r0, I flag
000400 ef0f
000401 bf0d
000402 e100
000403 bf0e                          LDSP    RAMEND
000404 dd30                          rcall   LCD_init
000405 ef00
000406 bb01                          OUTI    KPDD,0xf0          ; port D bits 0-3 as input (DDR = 0), 4-7 as output (DDR = 1)
000407 e00f
000408 bb02                          OUTI    KPDO,0x0f          ; drive bits 4-7 low = Colonnes a 0V
000409 ef0f
00040a bb07                          OUTI    DDRB,0xff          ; output for debug
00040b e00f
00040c bf09                          OUTI    EIMSK,0x0f         ; Enable external interrupts INT0-INT3
00040d e000
00040e bf0a                          OUTI    EICRB,0x00		   ; Condition d'interrupt au niveau bas pour int4-7 = colonnes
00040f 9bc7
000410 c002
000411 98c7
000412 c001
000413 9ac7                      	INVP	PORTB, 7
                                 
000414 24ee                          clr mask
000415 2700                      	clr w
000416 2711                      	clr _w
000417 24ff                      	clr wr2
000418 2411                      	clr wr1
000419 2422                      	clr wr0
00041a 2722                      	clr a0
00041b 2766                      	clr b0
00041c 2799                      	clr b3
00041d 2400                      	clr r0
00041e 9478                      	sei
00041f d007                          rcall clear_code
000420 940c 043f                 	jmp main
                                 
                                 
                                 
                                 print_code:
000422 322a                          cpi     a0, '*'
000423 f019                          breq    clear_code         ; Branch if key == *
                                 	;ldi a0, 'x'
                                 	;PRINTF LCD
                                 	;.db CR, CR, "Code:tst"
                                 	;.db 0
000424 dcf0                      	rcall LCD_putc
000425 24ff                      	clr wr2
000426 9508                          ret
                                 
                                 clear_code:
000427 dcf9                          rcall   LCD_clear
000428 e105
000429 2e40
00042a e001
00042b 2e50
00042c dd26                      	PRINTF LCD
00042d 0d0d
00042e 6f43
00042f 6564
000430 233a                      	.db	CR, CR, "Code:#"
C:\Users\arnob\Documents\EPFL\BA4\Microcontroleurs\PROJET\src\MicrocontroleursBA4\ProjetBA4\ProjetBA4\keypadv2.asm(195): warning: .cseg .db misalignment - padding zero byte
000431 0000                      	.db 0
000432 c00c                          rjmp main
                                 
                                 get_char: ;Lookup table index = 4*row + col
000433 e064                      	ldi     b0, 4
000434 9e16                          mul     wr1, b0          ; wr1 <-- detected row*4
000435 0c02                          add     r0, wr0          ; r0  <-- detected row*4 + detected column
000436 2d60                          mov     b0, r0           ; b0  <-- index of key (starts at 0)
000437 e0f8                          ldi     ZH, high(2*KeySet)
000438 eaec                          ldi     ZL, low(2*KeySet)
000439 0fe6                          add     ZL, b0
00043a e090                      	ldi		b3, 0x00
00043b 1ff9                          adc     ZH, b3			 ; Adjust ZH with carry
00043c 9124                          lpm     a0, Z  ; enregistre la valeur a l'adresse pointee par Z=r31:r30 dans a0
                                 	;rcall LCD_putc
00043d dfe4                      	rcall print_code
00043e c000                      	rjmp main
                                 
                                 ; === main program loop ===
                                 main:
                                 
                                     ;OUTI    DDRB,0xff          ; output for debug
                                     ;OUTI    EIMSK,0x0f         ; Enable external interrupts INT0-INT3
                                     ;OUTI    EICRB,0x00		   ; Condition d'interrupt au niveau bas pour int4-7 = colonnes
                                 	;OUTI	KPDO, 0xff
00043f ef0f                      	ldi w, 0xff
000440 16f0                      	cp wr2, w
000441 f389                      	breq get_char
000442 e104
000443 2e30
000444 e001
000445 930f
000446 923f
000447 e300
000448 2e30
000449 e006
00044a 943a
00044b f7f1
00044c 943a
00044d 950a
00044e f7d9
00044f 903f
000450 910f
000451 943a
000452 f791
000453 950a
000454 f781                      	WAIT_MS 20
                                 	;PRINTF LCD
                                 	;.db CR, CR, FBIN, wr1, 0
000455 cfe9                          rjmp    main
                                 
                                 ;go_to_get_char:
                                 	;INVP	PORTB, 5
                                 	;call get_char
                                 	;ret
                                 
                                 ; Keypad ASCII mapping table
                                 KeySet:
000456 3231
000457 4133                      .db '1', '2', '3', 'A'
000458 3534
000459 4236                      .db '4', '5', '6', 'B'
00045a 3837
00045b 4339                      .db '7', '8', '9', 'C'
00045c 302a


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega128" register use summary:
x  :   6 y  :   0 z  :   1 r0 :  10 r1 :   6 r2 :   6 r3 :  65 r4 :   2 
r5 :   2 r6 :   0 r7 :   0 r8 :   5 r9 :   5 r10:   5 r11:   6 r12:  11 
r13:   0 r14:   9 r15:   7 r16: 236 r17:   1 r18:  27 r19:  15 r20:  15 
r21:  15 r22:  14 r23:  25 r24:   7 r25:  18 r26:   4 r27:   4 r28:   0 
r29:   0 r30:  13 r31:   8 
Registers used: 29 out of 35 (82.9%)

"ATmega128" instruction use summary:
.lds  :   0 .sts  :   0 adc   :   1 add   :   4 adiw  :   5 and   :   4 
andi  :   7 asr   :   2 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   1 brcs  :   0 break :   0 breq  :  18 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   1 brlt  :   0 brmi  :   1 
brne  :  47 brpl  :   1 brsh  :   1 brtc  :   5 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   1 call  :   0 cbi   :   8 cbr   :   0 
clc   :   1 clh   :   0 cli   :   0 cln   :   0 clr   :  21 cls   :   0 
clt   :   1 clv   :   0 clz   :   0 com   :   8 cp    :   2 cpc   :   3 
cpi   :  11 cpse  :   0 dec   :  51 elpm  :   0 eor   :   0 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   1 ijmp  :   1 in    :   5 inc   :   2 
jmp   :   6 ld    :   6 ldd   :   0 ldi   : 106 lds   :   3 lpm   :  14 
lsl   :   1 lsr   :   3 mov   :  56 movw  :   0 mul   :   1 muls  :   0 
mulsu :   0 neg   :   0 nop   :   1 or    :   0 ori   :   2 out   :  14 
pop   :  41 push  :  40 rcall :  28 ret   :  13 reti  :   1 rjmp  :  61 
rol   :  10 ror   :  13 sbc   :   3 sbci  :   0 sbi   :   8 sbic  :   0 
sbis  :   8 sbiw  :   0 sbr   :   1 sbrc  :  11 sbrs  :   0 sec   :   0 
seh   :   0 sei   :   1 sen   :   0 ser   :   0 ses   :   0 set   :   1 
sev   :   0 sez   :   0 sleep :   0 spm   :   0 st    :   0 std   :   0 
sts   :   3 sub   :   3 subi  :   3 swap  :   4 tst   :  12 wdr   :   0 

Instructions used: 60 out of 114 (52.6%)

"ATmega128" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x0008bc   1390     26   1416  131072   1.1%
[.dseg] 0x000100 0x000102      0      2      2    4096   0.0%
[.eseg] 0x000000 0x000000      0      0      0    4096   0.0%

Assembly complete, 0 errors, 5 warnings
